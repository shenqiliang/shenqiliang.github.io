<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：iOS开发 | Xcode Dev]]></title>
  <link href="http://blog.xcodev.com/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://blog.xcodev.com/"/>
  <updated>2013-11-22T15:05:57+08:00</updated>
  <id>http://blog.xcodev.com/</id>
  <author>
    <name><![CDATA[谌启亮]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用CFStringTransform将汉字转换为拼音]]></title>
    <link href="http://blog.xcodev.com/blog/2013/11/22/tranform-hanzi-to-pinyin-using-cfstringtransform/"/>
    <updated>2013-11-22T11:47:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/11/22/tranform-hanzi-to-pinyin-using-cfstringtransform</id>
    <content type="html"><![CDATA[<p>之前做通讯录相关的一些App时，有一个比较常用的算法是将汉字转换成拼音。当时采用的做法是：将各个拼音段的首个汉字（按Unicode排序）做成两个数组，一个数组存拼音，另一个数组存拼音对应首个汉字的Unicode。如果要获取某个汉字的拼音，可以折半查找法找的对应拼音。最近无意间发现<a href="http://nshipster.com/cfstringtransform/">CFStringTransform</a>这篇文章后，发现系统本身已经提供了一个这样的函数。</p>

<!--more-->


<h2>CFStringTransform</h2>

<p>iOS在CoreFoundation中提供了CFStringTransform函数，但在Foundation中却没有相对应的方法。它的定义如下：</p>

<pre><code>Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse);
</code></pre>

<p>其中<code>string</code>参数是要转换的string，比如要转换的中文，同时它是mutable的，因此也直接作为最终转换后的字符串。<code>range</code>是要转换的范围，同时输出转换后改变的范围，如果为NULL，视为全部转换。<code>transform</code>可以指定要进行什么样的转换，这里可以指定多种语言的拼写转换。<code>reverse</code>指定该转换是否必须是可逆向转换的。如果转换成功就返回<code>true</code>，否则返回<code>false</code>。</p>

<p>如果要进行汉字到拼音的转换，我们只需要将<code>transform</code>设定为<code>kCFStringTransformMandarinLatin</code>或者<code>kCFStringTransformToLatin</code>（<code>kCFStringTransformToLatin</code>也可适用于非汉字字符串）:</p>

<pre><code>CFMutableStringRef string = CFStringCreateMutableCopy(NULL, 0, CFSTR("中国"));
CFStringTransform(string, NULL, kCFStringTransformMandarinLatin, NO);
NSLog(@"%@", string);
</code></pre>

<p>这段代码将输出：</p>

<pre><code>2013-11-22 14:41:14.644 Test[2436:907] zhōng guó
</code></pre>

<p>可以看出，<code>CFStringTransform</code>正确的输出了“中国”的拼音，而且还带上了音标。有时候我们不需要音标怎么办？还好<code>CFStringTransform</code>同时提供了将音标字母转换为普通字母的方法<code>kCFStringTransformStripDiacritics</code>。我们在上面的代码基础上再加上这个：</p>

<pre><code>CFStringTransform(string, NULL, kCFStringTransformStripDiacritics, NO);
NSLog(@"%@", string);
</code></pre>

<p>那么最终将输出：</p>

<pre><code>2013-11-22 14:47:00.380 Test[2470:907] zhong guo
</code></pre>

<h2>参考文章</h2>

<p><a href="http://nshipster.com/cfstringtransform/">http://nshipster.com/cfstringtransform/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[并发编程之GCD]]></title>
    <link href="http://blog.xcodev.com/blog/2013/11/04/gcd-intro/"/>
    <updated>2013-11-04T18:03:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/11/04/gcd-intro</id>
    <content type="html"><![CDATA[<p>在<a href="/blog/2013/10/28/operation-queue-intro/">《并发编程之Operation Queue》</a>中讲了Cocoa并发编程中的Operation Queue，了解了Operation Queue是一个面向对象的并发编程接口，它支持并发数，线程优先级，任务优先级，任务依赖关系等多种配置，可以方便满足各种复杂的多任务处理场景。本篇将接着讲另一种并发编程机制 &ndash; GCD（Grand Central Dispatch）。iOS4.0中首度引入GCD，GCD是管理任务执行的一项技术，它使得我们对多任务处理变得更加方便和有效。它支持同步或异步任务处理，串行或并行的处理队列（Dispath Queue），非系统调用的信号量机制，定时任务处理，进程、文件或网络的监听任务等。这个庞大的任务处理技术大大减少了线程的管理工作，使基于任务的开发变得更加高效。</p>

<!--more-->


<h2>Dispatch Queue</h2>

<p>Dispatch Queue是一个任务执行队列，可以让你异步或同步地执行多个Block或函数。Dispatch Queue是FIFO的，即先入队的任务总会先执行。目前有三种类型的Dispath Queue：</p>

<ul>
<li>串行队列（Serial dispatch queue）</li>
<li>并发队列（Concurrent dispatch queue）</li>
<li>主队列（Main dispatch queue）</li>
</ul>


<h3>串行队列</h3>

<p>串行队列一次只能处理一个任务，可以由用户调用<code>dispatch_queue_create</code>创建：</p>

<pre><code>dispatch_queue_t queue;
queue = dispatch_queue_create("com.example.MyQueue", NULL);
</code></pre>

<p>dispatch_queue_create第一个参数是串行队列标识，一般用反转域名的格式表示以防冲突；第二个参数是queue的类型，设为NULL时默认是<code>DISPATCH_QUEUE_SERIAL</code>，将创建串行队列，在必要情况下，你可以将其设置为<code>DISPATCH_QUEUE_CONCURRENT</code>来创建自定义并行队列。</p>

<h3>并行队列</h3>

<p>并行队列可以同时处理多个任务，在不得以的情况下可以用<code>dispatch_queue_create</code>创建，但一般我们都要用系统预定义的并行队列，即全局队列（Global Concurrent Dispatch Queues）。目前系统预定义了四个不同运行优先级的全局队列，我们可以通过<code>dispatch_get_global_queue</code>来获取它们。</p>

<pre><code>dispatch_queue_t aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</code></pre>

<p><code>dispatch_get_global_queue</code>第一个参数是队列的优先级，分别对应四个全局队列：</p>

<ul>
<li>DISPATCH_QUEUE_PRIORITY_HIGH</li>
<li>DISPATCH_QUEUE_PRIORITY_DEFAULT</li>
<li>DISPATCH_QUEUE_PRIORITY_LOW</li>
<li>DISPATCH_QUEUE_PRIORITY_BACKGROUND</li>
</ul>


<p><code>dispatch_get_global_queue</code>中第二个参数目前系统保留，请设置为0即可。</p>

<h3>主队列</h3>

<p>主队列是一个特殊的队列，它是系统预定义的运行在主线程的一个Dispatch Queue。可以通过<code>dispatch_get_main_queue</code>来获取唯一的主队列。主队列一般运行一些需要与主线程同步的一些短时任务。</p>

<pre><code>dispatch_queue_t mainQueue = dispatch_get_main_queue();
</code></pre>

<h3>获取当前队列</h3>

<p>你可以通过<code>dispatch_get_current_queue</code>获取运行时的队列：</p>

<pre><code>dispatch_queue_t currentQueue = dispatch_get_current_queue();
</code></pre>

<p>如果在队列执行任务中调用，返回执行此任务的队列；如果在主线程中调用，将返回主队列；如果在一般线程（非主线程线程非队列执行任务）中调用，返回<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>全局队列。</p>

<h3>在队列中运行任务</h3>

<p>你可以随时向一个队列中添加一个新任务，只需要调用一下<code>dispatch_async</code>即可：</p>

<pre><code>dispatch_async(aQueue, ^{
    //Do some work;
});
</code></pre>

<p><code>dispatch_async</code>中的任务是异步执行的，就是说<code>dispatch_async</code>添加任务到执行队列后会立刻返回，而不会等待任务执行完成。然而，必要的话，你也可以调用<code>dispatch_sync</code>来同步的执行一个任务：</p>

<pre><code>dispatch_sync(aQueue, ^{
    //Do some work;
});
</code></pre>

<p><code>dispatch_sync</code>会阻塞当前线程直到提交的任务完全执行完毕。</p>

<h3>Dispatch Queue的内存管理</h3>

<p>除了系统预定义的Dispatch Queue，我们自定义的Dispatch Queue需要手动的管理它的内存。<code>dispatch_retain</code>和<code>dispatch_release</code>这两个函数可以控制Dispatch Queue的引用计数（同时可以控制后面会讲到的Dispatch Group和Dispatch Source的引用计数）。当Dispatch Queue引用计数变为0后，就会调用finalizer，finalizer是Dispatch Queue销毁前调用的函数，用来清理Dispatch Queue的相关资源。可以用<code>dispatch_set_finalizer_f</code>函数来设置Dispatch Queue的finalizer，这个函数同时可以设置Dispatch Group和Dispatch Source的销毁函数（后面会讲到）。</p>

<pre><code>void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer);
</code></pre>

<h3>Dispatch Queue的上下文环境数据</h3>

<p>我们可以为每个Dispatch Queue设置一个自定义的上下文环境数据，调用<code>dispatch_set_context</code>来实现。同时我们也可以用<code>dispatch_get_context</code>获取这个上下文环境数据，这个函数同时可以设置Dispatch Group和Dispatch Source的上下文环境数据（后面会讲到）。</p>

<pre><code>void dispatch_set_context(dispatch_object_t object,void *context);
void * dispatch_get_context(dispatch_object_t object);
</code></pre>

<p>注意Dispatch Queue并不保证这个<code>context</code>不会释放，不会对它进行内存管理控制。我们需要自行管理<code>context</code>的内存分配和释放。一般我们非配内存设置<code>context</code>后，可以在finalizer里释放<code>context</code>占有的内存。</p>

<h2>并行执行循环</h2>

<p>在编程过程中，我们经常会用到<code>for</code>循环，而且<code>for</code>循环要做很多相关的任务。比如：</p>

<pre><code>for (i = 0; i &lt; count; i++) {
   //do a lot of work here.
   doSomething(i);
}
</code></pre>

<p>如果<code>for</code>循环中处理的任务是可并发的，显然放到一个线程中处理是很慢的，GCD提供两个函数<code>dispatch_apply</code>和<code>dispatch_apply_f</code>，<code>dispatch_apply</code>是用于Block的，而<code>dispatch_apply_f</code>可以用于c函数，它们可以替代可并发的<code>for</code>循环，来并行的运行而提高执行效率。</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(count, queue, ^(size_t i) {
   //do a lot of work here.
   doSomething(i);
});
</code></pre>

<h2>Dispatch Group</h2>

<p>有时候我们进行下一步操作，而这个操作需要等待几个任务处理完毕后才能继续，这时我们就需要用的Dispatch Group（类似thread join）。我们可以把若干个任务放到一个Dispatch Group中：</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{
   // Some asynchronous work
});
</code></pre>

<p><code>dispatch_group_async</code>跟<code>dispatch_async</code>一样，会把任务放到<code>queue</code>中执行，不过它比<code>dispatch_async</code>多做了一步操作就是把这个任务和<code>group</code>相关联。</p>

<p>把一些任务放到Dispatch Group后，我们就可以调用<code>dispatch_group_wait</code>来等待这些任务完成。若任务已经全部完成或为空，则直接返回，否则等待所有任务完成后返回。注意：返回后<code>group</code>会清空。</p>

<pre><code>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
// Do some work after.
dispatch_release(group);
</code></pre>

<h2>Dispatch信号量</h2>

<p>很多程序设计都设计到信号量，生产者-消费者模型在多线程编程中会频繁的使用。GCD提供了自己的一套信号量机制。</p>

<pre><code>dispatch_semaphore_t sema = dispatch_semaphore_create(RESOURCE_SIZE);
dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
//do some work here.
dispatch_semaphore_signal(sema);
</code></pre>

<p><code>dispatch_semaphore_wait</code>用来获取信号量，若信号量为0，则等待直到信号量大于0。在处理任务结束后，应释放相关资源并调用<code>dispatch_semaphore_signal</code>使信号量增加1个。</p>

<h2>Dispatch Source</h2>

<p>Dispatch Source是GCD中监听一些系统事件的有个Dispatch对象，它包括定时器、文件监听、进程监听、Mach port监听等类型。</p>

<p>可以通过<code>dispatch_source_create</code>创建一个Dispatch Source：</p>

<pre><code>dispatch_source_t dispatch_source_create(
   dispatch_source_type_t type,
   uintptr_t handle,
   unsigned long mask,
   dispatch_queue_t queue);
</code></pre>

<p>这里可以指定Dispatch Source的类型，<code>type</code>可以为文件读或写、进程监听等。<code>handle</code>为监听对象的句柄，如果是文件就是文件描述符，如果是进程就是进程ID。<code>mask</code>用来指定一些想要监听的事件，它的意义取决于<code>type</code>。<code>queue</code>指定事件处理的任务队列。</p>

<p>创建好Dispatch Source后，我们要为Dispatch Source设置一个事件处理模块。可以用<code>dispatch_source_set_event_handler</code>或<code>dispatch_source_set_event_handler_f</code>来设置：</p>

<pre><code>void dispatch_source_set_event_handler(
   dispatch_source_t source,
   dispatch_block_t handler);
</code></pre>

<p>设置好Dispatch Source后就可以调用<code>dispatch_resume</code>来启动监听。如果相应的事件发生就会触发事件处理模块。</p>

<p>同时我们也可以设置一个取消处理模块：</p>

<pre><code>dispatch_source_set_cancel_handler(mySource, ^{
   close(fd); // Close a file descriptor opened earlier.
});
</code></pre>

<p>取消处理模块会在Dispatch Source取消时调用。</p>

<p>下面介绍一下主要的Dispatch Source类型和示例代码。</p>

<h3>定时器</h3>

<p>定时器Dispatch Source可以每隔一个固定的时间处理一下任务。</p>

<pre><code>dispatch_source_t CreateDispatchTimer(uint64_t interval,
              uint64_t leeway,
              dispatch_queue_t queue,
              dispatch_block_t block)
{
   dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
                                                     0, 0, queue);
   if (timer)
   {
      dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), interval, leeway);
      dispatch_source_set_event_handler(timer, block);
      dispatch_resume(timer);
   }
   return timer;
}

void MyCreateTimer()
{
   dispatch_source_t aTimer = CreateDispatchTimer(30ull * NSEC_PER_SEC,
                               1ull * NSEC_PER_SEC,
                               dispatch_get_main_queue(),
                               ^{ MyPeriodicTask(); });

   // Store it somewhere for later use.
    if (aTimer)
    {
        MyStoreTimer(aTimer);
    }
}
</code></pre>

<h4>dispatch_after和dispatch_after_f</h4>

<p>有时候我们只想处理一次延迟任务，可以用dispatch_after和dispatch_after_f</p>

<pre><code>void dispatch_after(
   dispatch_time_t when,
   dispatch_queue_t queue,
   dispatch_block_t block);
</code></pre>

<h3>监听文件事件</h3>

<p>监听文件事件分好几个类型，有读、写、属性的监听。</p>

<h4>读取文件</h4>

<pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, fd, 0, queue);
dispatch_source_set_event_handler(source, ^{
   // Get some data from the source variable, which is captured
   // from the parent context.
   size_t estimated = dispatch_source_get_data(source);
   // Continue reading the descriptor...
});
dispatch_resume(source);
</code></pre>

<h4>写文件</h4>

<pre><code>dispatch_source_t writeSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE,
                        fd, 0, queue);
if (!writeSource)
{
    close(fd);
    return NULL;
}

dispatch_source_set_event_handler(writeSource, ^{
    size_t bufferSize = MyGetDataSize();
    void* buffer = malloc(bufferSize);

    size_t actual = MyGetData(buffer, bufferSize);
    write(fd, buffer, actual);

    free(buffer);

    // Cancel and release the dispatch source when done.
    dispatch_source_cancel(writeSource);
});
</code></pre>

<h4>监听文件属性</h4>

<pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE,
            fd, DISPATCH_VNODE_RENAME, queue);
if (source)
{
  // Copy the filename for later use.
  int length = strlen(filename);
  char* newString = (char*)malloc(length + 1);
  newString = strcpy(newString, filename);
  dispatch_set_context(source, newString);

  // Install the event handler to process the name change
  dispatch_source_set_event_handler(source, ^{
        const char*  oldFilename = (char*)dispatch_get_context(source);
        MyUpdateFileName(oldFilename, fd);
  });

  // Install a cancellation handler to free the descriptor
  // and the stored string.
  dispatch_source_set_cancel_handler(source, ^{
      char* fileStr = (char*)dispatch_get_context(source);
      free(fileStr);
      close(fd);
  });

  // Start processing events.
  dispatch_resume(source);
}
else
  close(fd);
</code></pre>

<h3>监听进程事件</h3>

<p><code>DISPATCH_PROC_EXIT</code>是一个监听进程退出的类型。</p>

<pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC,
                                                  parentPID, DISPATCH_PROC_EXIT, queue);
if (source)
{
   dispatch_source_set_event_handler(source, ^{
     MySetAppExitFlag();
     dispatch_source_cancel(source);
     dispatch_release(source);
   });
   dispatch_resume(source);
}
</code></pre>

<h3>监听中断信号</h3>

<pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGHUP, 0, queue);
if (source)
{
  dispatch_source_set_event_handler(source, ^{
     MyProcessSIGHUP();
  });

  // Start processing signals
  dispatch_resume(source);
}
</code></pre>

<h2>参考文献</h2>

<ul>
<li>Dispatch Queues：<a href="https://developer.apple.com/library/mac/documentation/general/conceptual/concurrencyprogrammingguide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1">https://developer.apple.com/library/mac/documentation/general/conceptual/concurrencyprogrammingguide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1</a></li>
<li>Dispatch Sources：<a href="https://developer.apple.com/library/mac/documentation/general/conceptual/concurrencyprogrammingguide/GCDWorkQueues/GCDWorkQueues.html">https://developer.apple.com/library/mac/documentation/general/conceptual/concurrencyprogrammingguide/GCDWorkQueues/GCDWorkQueues.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C代码注释和文档输出的工具和方法]]></title>
    <link href="http://blog.xcodev.com/blog/2013/11/01/code-comment-and-doc-gen-tools-for-objc/"/>
    <updated>2013-11-01T01:31:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/11/01/code-comment-and-doc-gen-tools-for-objc</id>
    <content type="html"><![CDATA[<p>代码注释可以让代码更容易接受和使用，特别是在大型项目合作开发或模块开发中。Objective-C中也有一些很方便的注释插件和文档生成工具。本文推荐两个开源软件：VVDocumenter注释工具和appledoc文档生成工具。</p>

<!--more-->


<h2>VVDocumenter</h2>

<p>首先推荐一个Xcode插件<a href="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter</a>，它可以让我们在代码中快捷的插入通用的注释代码。</p>

<p><img src="https://raw.github.com/onevcat/VVDocumenter-Xcode/master/ScreenShot.gif" alt="image" /></p>

<p>有了这个插件只需要在要注释的方法定义前输入三个斜杠（///），它就会自动为我们生成注释模板，这些注释模板可以用文档输出工具输出为说明文档。</p>

<h3>下载和安装VVDocumenter</h3>

<p>VVDocumenter插件是github上的一个开源项目，地址是<a href="https://github.com/onevcat/VVDocumenter-Xcode">https://github.com/onevcat/VVDocumenter-Xcode</a>。你可以<code>git clone</code>或在github网站上下载工程的zip压缩文件。下载完成后，打开其中的工程，build&amp;run一下就安装成功了。然后记得要重新启动一下Xcode应用，VVDocumenter插件就生效了。试试在方法定义前输入“///”。</p>

<h2>appledoc</h2>

<p>我们开发自己的模块时，经常会将模块接口提供给别人使用，这样我们不得不写一些接口说明文档。很多语言都提供了这种工具比如javadoc，doxygen等，可以将注释代码转化成在线文档。这里推荐一个特别适合Objective-C语言的一种文档输出工具<a href="https://github.com/tomaz/appledoc">appledoc</a>。它可以把一些格式的注释转换成Apple SDK风格的文档，同时它支持VVDocumenter的输出注释格式。</p>

<h3>安装appledoc</h3>

<p>建议使用brew命令来安装，如果没有安装brew，可以先用一下命令安装一下：</p>

<pre><code>ruby -e "$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)"：
</code></pre>

<p>然后执行brew安装命令来安装appledoc</p>

<pre><code>brew install appledoc
</code></pre>

<h3>使用appledoc生成文档</h3>

<pre><code>appledoc [OPTIONS] &lt;paths to source dirs or files&gt;
</code></pre>

<p>该命令将生成并安装文档到Xcode，可以通过Xcode的文档浏览器来查看文档，并可以在Xcode中搜索到相关接口。</p>

<p><img src="/images/post/xcode-doc-prev-apple-doc.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[并发编程之Operation Queue]]></title>
    <link href="http://blog.xcodev.com/blog/2013/10/28/operation-queue-intro/"/>
    <updated>2013-10-28T11:26:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/10/28/operation-queue-intro</id>
    <content type="html"><![CDATA[<p>随着移动设备的更新换代，移动设备的性能也不断提高，现在流行的CPU已经进入双核、甚至四核时代。如何充分发挥这些CPU的性能，会变得越来越重要。在iOS中如果想要充分利用多核心CPU的优势，就要采用并发编程，提高CPU的利用率。iOS中并发编程中主要有2种方式Operation Queue和GCD（Grand Central Dispatch）。下面就来先来说一下Operation Queue。</p>

<!--more-->


<h2>异步调用和并发</h2>

<p>在深入之前，首先说说异步调用和并发。这两个概念在并发编程中很容易弄混淆。异步调用是指调用时无需等待结果返回的调用，异步调用往往会触发后台线程处理，比如NSURLConnection的异步网络回调。并发是指多个任务（线程）同时执行。在异步调用的实现中往往采用并发机制，然而并不是所有异步都是并发机制，也有可能是其他机制，比如一些依靠中断进行的操作。</p>

<h2>为什么Operation Queue</h2>

<p>Operation Queue提供一个面向对象的并发编程接口，支持并发数，线程优先级，任务优先级，任务依赖关系等多种配置，可以方便满足各种复杂的多任务处理场景。</p>

<ul>
<li>面向对象接口</li>
<li>支持并发数配置</li>
<li>任务优先级调度</li>
<li>任务依赖关系</li>
<li>线程优先级配置</li>
</ul>


<h2>NSOperation简介</h2>

<p>iOS并发编程中，把每个并发任务定义为一个Operation，对应的类名是NSOperation。NSOperation是一个抽象类，无法直接使用，它只定义了Operation的一些基本方法。我们需要创建一个继承于它的子类或者使用系统预定义的子类。目前系统预定义了两个子类：NSInvocationOperation和NSBlockOperation。</p>

<h3>NSInvocationOperation</h3>

<p>NSInvoationOperation是一个基于对象和selector的Operation，使用这个你只需要指定对象以及任务的selector，如果必要，你还可以设定传递的对象参数。</p>

<pre><code>NSInvocationOperation *invacationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(doSomethingWithObj:) object:obj];
</code></pre>

<p>同时当这个Operation完成后，你还可以获取Operation中Invation执行后返回的结果对象。</p>

<pre><code>id result = [invacationOperation result];
</code></pre>

<h3>NSBlockOperation</h3>

<p>在一个Block中执行一个任务，这时我们就需要用到NSBlockOperation。可以通过<code>blockOperationWithBlock:</code>方法来方便地创建一个NSBlockOperation：</p>

<pre><code>NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
    //Do something here.
}];
</code></pre>

<h3>运行一个Operation</h3>

<p>调用Operation的<code>start</code>方法就可以直接运行一个Operation。</p>

<pre><code>[operation start];
</code></pre>

<p><code>start</code>方法用来启动一个Operation任务。同时，Operation提供一个<code>main</code>方法，你的所有任务都应该在main中进行处理。默认的<code>start</code>方法中会先做出一些异常判断然后直接调用<code>main</code>方法。如果需要自定义一个NSOperation必须重载<code>main</code>方法来执行你所想要执行的任务。</p>

<pre><code>@implementation CustomOperation

-(void)main {
   @try {
      // Do some work.
   }
   @catch(...) {
      // Exception handle.
   }
}
@end
</code></pre>

<h3>取消一个Operation</h3>

<p>要取消一个Operation，要向Operation对象发送cancel消息：</p>

<pre><code>[operation cancel];
</code></pre>

<p>当向一个Operation对象发送cancel消息后，并不保证这个Operation对象一定能立刻取消，这取决于你的<code>main</code>中对<code>cancel</code>的处理。如果你在<code>main</code>方法中没有对<code>cancel</code>进行任何处理的话，发送<code>cancel</code>消息是没有任何效果的。为了让Operation响应<code>cancel</code>消息，那么你就要在<code>main</code>方法中一些适当的地方手动的判断<code>isCancelled</code>属性，如果返回<code>YES</code>的话，应释放相关资源并立刻停止继续执行。</p>

<h3>创建可并发的Operation</h3>

<p>由于默认情况下Operation的<code>start</code>方法中直接调用了<code>main</code>方法，而<code>main</code>方法中会有比较耗时的处理任务。如果我们在一段代码连续<code>start</code>了多个Operation，这些Operation都是阻塞地依次执行完，因为第二个Operation必须等到第一个Operation执行完<code>start</code>内的<code>main</code>并返回。Operation默认都是不可并发的（使用了Operation Queue情况下除外，Operation Queue会独自管理自己的线程），因为默认情况下Operation并不额外创建线程。我们可以通过Operation的<code>isConcurrent</code>方法来判断Operation是否是可并发的。如果要让Operation可并发，我们需要让<code>main</code>在独立的线程中执行，并将<code>isConcurrent</code>返回YES。</p>

<pre><code>@implementation MyOperation{
    BOOL        executing;
    BOOL        finished;
}


- (BOOL)isConcurrent {
    return YES;
}

- (void)start {
   if ([self isCancelled])
   {
      [self willChangeValueForKey:@"isFinished"];
      finished = YES;
      [self didChangeValueForKey:@"isFinished"];
      return;
   }

   [self willChangeValueForKey:@"isExecuting"];
   [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];
   executing = YES;
   [self didChangeValueForKey:@"isExecuting"];
}

- (void)main {
   @try {
        // Do some work.

        [self willChangeValueForKey:@"isFinished"];
        [self willChangeValueForKey:@"isExecuting"];
        executing = NO;
        finished = YES;
        [self didChangeValueForKey:@"isExecuting"];
        [self didChangeValueForKey:@"isFinished"];

   }
   @catch(...) {
      // Exception handle.
   }
}

@end
</code></pre>

<p>当你自定义了<code>start</code>或<code>main</code>方法时，一定要手动的调用一些KVO通知方法，以便让对象的KVO机制可以正常运作。</p>

<h3>设置Operation的completionBlock</h3>

<p>每个Operation都可以设置一个<code>completionBlock</code>，在Operation执行完成时自动执行这个Block。我们可以在此进行一些完成的处理。<code>completionBlock</code>实现原理是对Operation的<code>isFinnshed</code>字段进行KVO（Key-Value Observing），当监听到<code>isFinnished</code>变成YES时，就执行<code>completionBlock</code>。</p>

<pre><code>operation.completionBlock = ^{
    NSLog(@"finished");
};
</code></pre>

<h3>设置Operation的线程优先级</h3>

<p>我们可以为Operation设置一个线程优先级，即<code>threadPriority</code>。那么执行<code>main</code>的时候，线程优先级就会调整到所设置的线程优先级。这个默认值是0.5，我们可以在Operation执行前修改它。</p>

<pre><code>operation.threadPriority = 0.1;
</code></pre>

<p>注意：如果你重载的<code>start</code>方法，那么你需要自己来配置<code>main</code>执行时的线程优先级和<code>threadPriority</code>字段保持一致。</p>

<h3>Operation状态变化</h3>

<p>我们可以通过KVO机制来监听Operation的一下状态改变，比如一个Operation的执行状态或完成状态。这些状态的keypath包括以下几个：</p>

<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>


<h2>NSOperationQueue</h2>

<p>NSOperationQueue是一个Operation执行队列，你可以将任何你想要执行的Operation添加到Operation Queue中，以在队列中执行。同时Operation和Operation Queue提供了很多可配置选项。Operation Queue的实现中，创建了一个或多个可管理的线程，为队列中的Operation提供可高度自定的执行环境。</p>

<h3>Operation的依赖关系</h3>

<p>有时候我们对任务的执行顺序有要求，一个任务必须在另一个任务执行之前完成，这就需要用到Operation的依赖（Dependency）属性。我们可以为每个Operation设定一些依赖的另外一些Operation，那么如果依赖的Operation没有全部执行完毕，这个Operation就不会被执行。</p>

<pre><code>[operation addDependency:anotherOperation];
[operation removeDependency:anotherOperation];
</code></pre>

<p>如果将这些Operation和它所依赖的Operation加如队列中，那么Operation只有在它依赖的Operation都执行完毕后才可以被执行。这样我们就可以方便的控制Operation执行顺序。</p>

<h3>Operation在队列中执行的优先级</h3>

<p>Operation在队列中默认是按FIFO（First In First Out）顺序执行的。同时我们可以为单个的Operation设置一个执行的优先级，打乱这个顺序。当Queue有空闲资源执行新的Operation时，会优先执行当前队列中优先级最高的待执行Operation。</p>

<h3>最大并发Operation数目</h3>

<p>在一个Operation Queue中是可以同时执行多个Operation的，Operation Queue会动态的创建多个线程来完成相应Operation。具体的线程数是由Operation Queue来优化配置的，这一般取决与系统CPU的性能，比如CPU的核心数，和CPU的负载。但我们还是可以设置一个最大并发数的，那么Operation Queue就不会创建超过最大并发数量的线程。</p>

<pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];
queue.maxConcurrentOperationCount = 1;
</code></pre>

<p>如果我们将<code>maxConcurrentOperationCount</code>设置为<code>1</code>，那么在队列中每次只能执行一个任务。这就是一个串行的执行队列了。</p>

<h3>Simple Code</h3>

<p>下面我写了一个简单的Simple Code来说明一下Operation和Operation Queue。</p>

<pre><code>NSBlockOperation *operation5s = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"operation5s begin");
    sleep(5);
    NSLog(@"operation5s end");
}];
operation5s.queuePriority = NSOperationQueuePriorityHigh;
NSBlockOperation *operation1s = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"operation1s begin");
    sleep(1);
    NSLog(@"operation1s end");
}];
NSBlockOperation *operation2s = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"operation2s begin");
    sleep(2);
    NSLog(@"operation2s end");
}];

operation1s.completionBlock = ^{
    NSLog(@"operation1s finished in completionBlock");
};

NSOperationQueue *queue = [[NSOperationQueue alloc] init];
queue.maxConcurrentOperationCount = 1;
[queue addOperation:operation1s];
[queue addOperation:operation2s];
[queue addOperation:operation5s];
[queue waitUntilAllOperationsAreFinished];
</code></pre>

<p>运行这段代码，我得到了一下输出结果：</p>

<pre><code>operation1s begin
operation1s end
operation5s begin
operation1s finished in completionBlock
operation5s end
operation2s begin
operation2s end
</code></pre>

<p>为了更好的展示队列优先级效果，我把queue的<code>maxConcurrentOperationCount</code>设置为<code>1</code>，以便任务一个一个的执行。从上面日志可以看出，第一个operation1s执行完毕后，会执行operation5s，而不是operation2s，因为operation5s的<code>queuePriority</code>是<code>NSOperationQueuePriorityHigh</code>。而第一个线程总是会第一个执行。在看看2-4行，我们可以看出operation1s的<code>completionBlock</code>比operation5s晚开始执行，说明它不在operation1s的线程中执行的。正如前面所说，<code>completionBlock</code>是通过KVO监听执行，一般会运行在监听所在线程，而不是Operation执行的线程。</p>

<h2>注意事项</h2>

<ul>
<li>当一个Operation被加入Queue中后，请不要对这个Operation再进行任何修改。因为一旦加入Queue，它随时就有可能会被执行，对它的任何修改都有可能导致它的运行状态不可控制。</li>
<li><code>threadPriority</code>仅仅影响了<code>main</code>执行时的线程优先级，其他的方法包括<code>completionBlock</code>都是以默认的优先级来执行的。如果自定义的话，也要注意在<code>main</code>执行前设置好<code>threadPriority</code>，执行完毕后要还原默认线程优先级。</li>
<li>经测试，Operation的<code>threadPriority</code>字段只有在Operation单独执行时有效，在Operation Queue中是无效的。</li>
<li>第一个加入到Operation Queue中的Operation，无论它的优先级有多么低，总是会第一个执行。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[64位与Tagged Pointer]]></title>
    <link href="http://blog.xcodev.com/blog/2013/10/21/tagged-pointer-and-64-bit/"/>
    <updated>2013-10-21T16:09:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/10/21/tagged-pointer-and-64-bit</id>
    <content type="html"><![CDATA[<p>在Mac OS X 10.6（Snow Leopard）中开始支持64位，如今最新版本iPhone 5s也开始采用了Arm64架构。在64位化的过程中，其中一个比较关键的改进就是，Mac OS 10.7（Lion）和iOS 7的64位环境先后引入了Tagged Pointer。下面就简单地来介绍一下Tagged Pointer，在介绍Tagged Pointer之前有必要介绍一下指针地址对齐概念和64位环境的一些变化。</p>

<!--more-->


<h2>指针地址对齐</h2>

<p>在32位环境下，如果要读取一个32位整数，如果这个32位整数在内存地址为0x00000002-0x00000006（仅作举例，这个地址一般是被系统保留的）的内存上，读取这个整数会消耗2个CPU周期，而如果这个数在0x00000004-0x00000008的内存上只需要一个CPU周期。为了加快内存的CPU访问，程序都使用了指针地址对齐概念。指针地址对齐就是指在分配堆中的内存时往往采用偶数倍或以2为指数倍的内存地址作为地址边界。几乎所有系统架构，包括Mac OS和iOS，都使用了地址对齐概念。</p>

<pre><code>void *a = malloc(1);
void *b = malloc(3);
NSLog(@"a: %p",a);
NSLog(@"b: %p",b);
</code></pre>

<p>运行这段代码后，我得到了如下结果：</p>

<pre><code>a: 0x8c11e20
b: 0x8c11e30
</code></pre>

<p>可以看到，a和b指针的最后4位都是0，虽然a只占用1个字节，但是a和b的地址却相差16个字节。因为iOS中是以16个字节为内存分配边界的，或者说iOS的指针地址对齐是以16个字节为对齐边界的。进一步说，iOS中分配的内存地址最后4位永远都是0。</p>

<h2>64位地址</h2>

<p>在不久前发布iPhone5s中采用了Arm64的CPU，同时也支持了64位的App。64位App中指针大小也扩大到64位，就是理论上可以支持最大2<sup>64</sup>字节（达千万T字节）的内存地址空间。而对于大多数应用来说，这么大的地址空间完全是浪费的。也就是说64位环境下，内存地址的前面很多位一般都是0。</p>

<h2>Tagged Pointer</h2>

<p>由于指针地址对齐概念和64位超大地址的出现，指针地址仅仅作为内存的地址是比较浪费的，我们可以在指针地址中保存或附加更多的信息。这就引入了Tagged Pointer概念。Tagged Pointer是指那些指针中包含特殊属性或信息的指针。其中指针对齐概念可以让我们来标识一个指针是否是Tagged Pointer以及相关类型，64位的地址指针又为我们提供保存额外信息的足够空间。如今，iOS 7的64位环境和Mac OS 10.7（Lion）中开始引入了Tagged Pointer。</p>

<h2>NSNumber的优化</h2>

<p>Tagged Pointer一个比较典型的应用就是NSNumber，在64位环境下，对于一般的数字，NSNumber不用再分配内存了。我们看看NSNumber是如何运用Tagged Pointer的：</p>

<pre><code>NSNumber *number3 = @3;
NSNumber *number4 = @4;
NSNumber *number9 = @9;
NSLog(@"number3 pointer is %p", number3);
NSLog(@"number4 pointer is %p", number4);
NSLog(@"number9 pointer is %p", number9);
</code></pre>

<p>在64位模拟器中运行后，我得到了如下结果：</p>

<pre><code>number3 pointer is 0xb000000000000032
number4 pointer is 0xb000000000000042
number9 pointer is 0xb000000000000092
</code></pre>

<p>可以看出<code>number3</code>、<code>number4</code>和<code>number9</code>的值前4位都是0xb，后4位都是0x2（指针的Tag），中间就是实际的取值，因此，这些NSNumber已经不需要再分配内存（指堆中内存）了，直接可以把实际的值保存到指针中，而无需再去访问堆中的数据。这无疑提高的内存访问速度和整体运算速度。</p>

<p>也就是说Tagged Pointer本身就可以表示一个NSNumber了，在64位环境下运行这段代码：</p>

<pre><code>NSLog(@"0xb000000000000052's class is %@",[(NSNumber*)0xb000000000000052 class]);
</code></pre>

<p>会输出下面结果：</p>

<pre><code>0xb000000000000052's class is __NSCFNumber
</code></pre>

<p>那么如果一个数超过了Tagged Pointer所能表示的范围，系统会怎么处理？看看这段代码：</p>

<pre><code>NSNumber *numberBig = @(0x1234567890ABCDEF);
NSLog(@"numberBig pointer is %p", numberBig);
</code></pre>

<p>在64位模拟器中运行后，我得到了如下结果：</p>

<pre><code>numberBig pointer is 0x1094026a0
</code></pre>

<p>可以看出<code>numberBig</code>指针最后4位都是0，应该是分配在堆中的对象。因此，如果NSNumber超出了Tagged Pointer所能表示的范围，系统会自动采用分配成对象，可以根据指针的最后4位是否为0来区分。</p>

<h2>isa指针优化</h2>

<p>查看NSObject类的头文件，你会发现这段定义：</p>

<pre><code>@interface NSObject &lt;NSObject&gt; {
    Class isa;
}
</code></pre>

<p>所有类都继承自NSObject，因此每个对象都有一个isa<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>指针指向它所属的类。在《<a href="http://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html">ARM64 and You</a>》文章中指出：</p>

<p>在32位环境下，对象的引用计数都保存在一个外部的表中，而对引用计数的增减操作都要先锁定这个表，操作完成后才解锁。这个效率是非常慢的。</p>

<p>而在64位环境下，isa也是64位，实际作为指针部分只用到的其中33位，剩余的部分会运用到Tagged Pointer的概念，其中19位将保存对象的引用计数，这样对引用计数的操作只需要原子的修改这个指针即可，如果引用计数超出19位，才会将引用计数保存到外部表，而这种情况往往是很少的，因此效率将会大大提高。</p>

<h2>参考文献</h2>

<ul>
<li>Objective-C对象模型及应用： <a href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/">http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/</a></li>
<li>ARM64 and You：<a href="http://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html">http://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html</a></li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>isa是“is a”，比如“Apple is a company”，表示一种从属关系。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
