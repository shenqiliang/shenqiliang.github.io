<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Xcode Dev]]></title>
  <link href="http://blog.xcodev.com/atom.xml" rel="self"/>
  <link href="http://blog.xcodev.com/"/>
  <updated>2013-12-11T11:50:06+08:00</updated>
  <id>http://blog.xcodev.com/</id>
  <author>
    <name><![CDATA[谌启亮]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[“#”的迷雾]]></title>
    <link href="http://blog.xcodev.com/blog/2013/12/16/mists-of-the-sharp/"/>
    <updated>2013-12-16T12:38:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/12/16/mists-of-the-sharp</id>
    <content type="html"><![CDATA[<p>在代码中使用Autolayout时，大家都会使用<code>NSDictionaryOfVariableBindings</code>这个宏，这个宏可以生成一个变量名到变量值映射的Dictionary。比如<code>NSDictionaryOfVariableBindings(button1, button2)</code>将会生成一个<code>{ @"button1" = button1, @"button2 = button2 }</code>的Dictionary。它是怎么做到的呢？我们来看看这个宏的定义：</p>

<pre><code>#define NSDictionaryOfVariableBindings(...) _NSDictionaryOfVariableBindings(@"" # __VA_ARGS__, __VA_ARGS__, nil)
</code></pre>

<p>这个宏定义中有3个参数，后两个参数不难理解，但第一个参数中间有个<code>#</code>符号，语法上看起来比较怪异，这个是什么呢？以前在做越狱的mobilesubstrate开发时，其中定义的一堆宏频繁使用了这个符号，下面就来揭开<code>#</code>这个符号在宏定义中的迷雾。</p>

<!--more-->


<h2>预编译的一些知识</h2>

<p>我们的代码在build时并不是直接进行编译的，在编译之前还进行了预编译处理。预编译会把include或import的文件导入到文件中，同时会将代码中用到的宏进行替换。注意宏是直接在代码中替换成宏的定义的，如果有嵌套也会逐层替换。</p>

<h2>&ldquo;#&#8221;指示一些预编译命令</h2>

<p>预编译命令一般都是以<code>#</code>开头的，比如<code>#include</code>、<code>#import</code>、<code>#if</code>等，在这里就不一一说明了，本文主要说明一下<code>#</code>在宏定义里面的一些作用。</p>

<h2>宏参数字符串化</h2>

<p>在一个参数前加一个<code>#</code>，预处理时将会变成这个参数名的字符串常量，即字符串化（stringify）。比如:</p>

<pre><code>#define GET_NAME(X) #X
int a = 0;
NSLog(@"%s",GET_NAME(a));      //output: "a"
NSLog(@"%s",GET_NAME(a+3));    //output: "a+3"
</code></pre>

<p>将会得到以下输出：</p>

<pre><code>a
a+3
</code></pre>

<p>可以看出<code>#</code>，将参数原样转换成字符串常量，如果参数是一个表达式，那么输出这个表达式的原样字符串常量。</p>

<p>回头再看看<code>NSDictionaryOfVariableBindings</code>的定义：</p>

<pre><code>#define NSDictionaryOfVariableBindings(...) _NSDictionaryOfVariableBindings(@"" # __VA_ARGS__, __VA_ARGS__, nil)
</code></pre>

<p>如果这样生成两个button的映射：</p>

<pre><code>NSDictionaryOfVariableBindings(button1, button2);
</code></pre>

<p>那么预编译时就会转换成：</p>

<pre><code>_NSDictionaryOfVariableBindings(@"""button1, button2", button1, button2, nil);
</code></pre>

<p>由于两个常量字符串放在一起就是字符串常量串联，将变成两个字符串常量组合在一起的字符串常量，也就是上面是一个空字符串<code>""</code>和<code>"button1, button2"</code>串联，所以上面的代码等价于：</p>

<pre><code>_NSDictionaryOfVariableBindings(@"button1, button2", button1, button2, nil);
</code></pre>

<p>那么<code>_NSDictionaryOfVariableBindings</code>函数就可以将它的第一个参数按逗号<code>,</code>分割开作为key，后面就是各个key对应的值了。因此这段代码就创建了一个内容为<code>{ @"button1" = button1, @"button2 = button2 }</code>的Dictionary。</p>

<h2>命名的串联</h2>

<p><code>#</code>在宏定义中的另一个作用就是用于命名的串联，用<code>##</code>就可以串联它左右两边的命名，比如以下代码：</p>

<pre><code>#define CONCAT(X, Y) X ## Y
NSString *helloworld = @"Hello, world!";
NSLog(@"%@",CONCAT(hello, world)); //output: "Hello, world"
</code></pre>

<p><code>CONCAT(hello, world)</code>实际被转换成<code>helloworld</code>。注意一下，因为宏是预编译阶段进行展开的，就是说在编译之前，因此代码中的<code>hello</code>和<code>world</code>即使没有定义其实也是没问题的，预编译处理后，这两个命名是不存在的。</p>

<h2>可选可变参数</h2>

<p><code>##</code>在宏定义中可以放在<code>__VA_ARGS__</code>之前表示可变参数可以为空，否则的话可变参数至少为一个了。</p>

<pre><code>#define MYLOG(format, ...) NSLog(format, ##__VA_ARGS__)
MYLOG(@"Don't make an error!");
</code></pre>

<p>上面代码中MLOG中只有一个参数，如果不加<code>##</code>，则MLOG至少需要两个参数，在Xcode里将会出现编译错误。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用CFStringTransform将汉字转换为拼音]]></title>
    <link href="http://blog.xcodev.com/blog/2013/11/22/tranform-hanzi-to-pinyin-using-cfstringtransform/"/>
    <updated>2013-11-22T11:47:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/11/22/tranform-hanzi-to-pinyin-using-cfstringtransform</id>
    <content type="html"><![CDATA[<p>之前做通讯录相关的一些App时，有一个比较常用的算法是将汉字转换成拼音。当时采用的做法是：将各个拼音段的首个汉字（按Unicode排序）做成两个数组，一个数组存拼音，另一个数组存拼音对应首个汉字的Unicode。如果要获取某个汉字的拼音，可以折半查找法找的对应拼音。最近无意间发现<a href="http://nshipster.com/cfstringtransform/">CFStringTransform</a>这篇文章后，发现系统本身已经提供了一个这样的函数。</p>

<!--more-->


<h2>CFStringTransform</h2>

<p>iOS在CoreFoundation中提供了CFStringTransform函数，但在Foundation中却没有相对应的方法。它的定义如下：</p>

<pre><code>Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse);
</code></pre>

<p>其中<code>string</code>参数是要转换的string，比如要转换的中文，同时它是mutable的，因此也直接作为最终转换后的字符串。<code>range</code>是要转换的范围，同时输出转换后改变的范围，如果为NULL，视为全部转换。<code>transform</code>可以指定要进行什么样的转换，这里可以指定多种语言的拼写转换。<code>reverse</code>指定该转换是否必须是可逆向转换的。如果转换成功就返回<code>true</code>，否则返回<code>false</code>。</p>

<p>如果要进行汉字到拼音的转换，我们只需要将<code>transform</code>设定为<code>kCFStringTransformMandarinLatin</code>或者<code>kCFStringTransformToLatin</code>（<code>kCFStringTransformToLatin</code>也可适用于非汉字字符串）:</p>

<pre><code>CFMutableStringRef string = CFStringCreateMutableCopy(NULL, 0, CFSTR("中国"));
CFStringTransform(string, NULL, kCFStringTransformMandarinLatin, NO);
NSLog(@"%@", string);
</code></pre>

<p>这段代码将输出：</p>

<pre><code>2013-11-22 14:41:14.644 Test[2436:907] zhōng guó
</code></pre>

<p>可以看出，<code>CFStringTransform</code>正确的输出了“中国”的拼音，而且还带上了音标。有时候我们不需要音标怎么办？还好<code>CFStringTransform</code>同时提供了将音标字母转换为普通字母的方法<code>kCFStringTransformStripDiacritics</code>。我们在上面的代码基础上再加上这个：</p>

<pre><code>CFStringTransform(string, NULL, kCFStringTransformStripDiacritics, NO);
NSLog(@"%@", string);
</code></pre>

<p>那么最终将输出：</p>

<pre><code>2013-11-22 14:47:00.380 Test[2470:907] zhong guo
</code></pre>

<h2>参考文章</h2>

<p><a href="http://nshipster.com/cfstringtransform/">http://nshipster.com/cfstringtransform/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[并发编程之GCD]]></title>
    <link href="http://blog.xcodev.com/blog/2013/11/04/gcd-intro/"/>
    <updated>2013-11-04T18:03:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/11/04/gcd-intro</id>
    <content type="html"><![CDATA[<p>在<a href="http://blog.xcodev.com/blog/2013/10/28/operation-queue-intro/">《并发编程之Operation Queue》</a>中讲了Cocoa并发编程中的Operation Queue，了解了Operation Queue是一个面向对象的并发编程接口，它支持并发数，线程优先级，任务优先级，任务依赖关系等多种配置，可以方便满足各种复杂的多任务处理场景。本篇将接着讲另一种并发编程机制 &ndash; GCD（Grand Central Dispatch）。iOS4.0中首度引入GCD，GCD是管理任务执行的一项技术，它使得我们对多任务处理变得更加方便和有效。它支持同步或异步任务处理，串行或并行的处理队列（Dispath Queue），非系统调用的信号量机制，定时任务处理，进程、文件或网络的监听任务等。这个庞大的任务处理技术大大减少了线程的管理工作，使基于任务的开发变得更加高效。</p>

<!--more-->


<h2>Dispatch Queue</h2>

<p>Dispatch Queue是一个任务执行队列，可以让你异步或同步地执行多个Block或函数。Dispatch Queue是FIFO的，即先入队的任务总会先执行。目前有三种类型的Dispath Queue：</p>

<ul>
<li>串行队列（Serial dispatch queue）</li>
<li>并发队列（Concurrent dispatch queue）</li>
<li>主队列（Main dispatch queue）</li>
</ul>


<h3>串行队列</h3>

<p>串行队列一次只能处理一个任务，可以由用户调用<code>dispatch_queue_create</code>创建：</p>

<pre><code>dispatch_queue_t queue;
queue = dispatch_queue_create("com.example.MyQueue", NULL);
</code></pre>

<p>dispatch_queue_create第一个参数是串行队列标识，一般用反转域名的格式表示以防冲突；第二个参数是queue的类型，设为NULL时默认是<code>DISPATCH_QUEUE_SERIAL</code>，将创建串行队列，在必要情况下，你可以将其设置为<code>DISPATCH_QUEUE_CONCURRENT</code>来创建自定义并行队列。</p>

<h3>并行队列</h3>

<p>并行队列可以同时处理多个任务，在不得以的情况下可以用<code>dispatch_queue_create</code>创建，但一般我们都要用系统预定义的并行队列，即全局队列（Global Concurrent Dispatch Queues）。目前系统预定义了四个不同运行优先级的全局队列，我们可以通过<code>dispatch_get_global_queue</code>来获取它们。</p>

<pre><code>dispatch_queue_t aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</code></pre>

<p><code>dispatch_get_global_queue</code>第一个参数是队列的优先级，分别对应四个全局队列：</p>

<ul>
<li>DISPATCH_QUEUE_PRIORITY_HIGH</li>
<li>DISPATCH_QUEUE_PRIORITY_DEFAULT</li>
<li>DISPATCH_QUEUE_PRIORITY_LOW</li>
<li>DISPATCH_QUEUE_PRIORITY_BACKGROUND</li>
</ul>


<p><code>dispatch_get_global_queue</code>中第二个参数目前系统保留，请设置为0即可。</p>

<h3>主队列</h3>

<p>主队列是一个特殊的队列，它是系统预定义的运行在主线程的一个Dispatch Queue。可以通过<code>dispatch_get_main_queue</code>来获取唯一的主队列。主队列一般运行一些需要与主线程同步的一些短时任务。</p>

<pre><code>dispatch_queue_t mainQueue = dispatch_get_main_queue();
</code></pre>

<h3>获取当前队列</h3>

<p>你可以通过<code>dispatch_get_current_queue</code>获取运行时的队列：</p>

<pre><code>dispatch_queue_t currentQueue = dispatch_get_current_queue();
</code></pre>

<p>如果在队列执行任务中调用，返回执行此任务的队列；如果在主线程中调用，将返回主队列；如果在一般线程（非主线程线程非队列执行任务）中调用，返回<code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>全局队列。</p>

<h3>在队列中运行任务</h3>

<p>你可以随时向一个队列中添加一个新任务，只需要调用一下<code>dispatch_async</code>即可：</p>

<pre><code>dispatch_async(aQueue, ^{
    //Do some work;
});
</code></pre>

<p><code>dispatch_async</code>中的任务是异步执行的，就是说<code>dispatch_async</code>添加任务到执行队列后会立刻返回，而不会等待任务执行完成。然而，必要的话，你也可以调用<code>dispatch_sync</code>来同步的执行一个任务：</p>

<pre><code>dispatch_sync(aQueue, ^{
    //Do some work;
});
</code></pre>

<p><code>dispatch_sync</code>会阻塞当前线程直到提交的任务完全执行完毕。</p>

<h3>Dispatch Queue的内存管理</h3>

<p>除了系统预定义的Dispatch Queue，我们自定义的Dispatch Queue需要手动的管理它的内存。<code>dispatch_retain</code>和<code>dispatch_release</code>这两个函数可以控制Dispatch Queue的引用计数（同时可以控制后面会讲到的Dispatch Group和Dispatch Source的引用计数）。当Dispatch Queue引用计数变为0后，就会调用finalizer，finalizer是Dispatch Queue销毁前调用的函数，用来清理Dispatch Queue的相关资源。可以用<code>dispatch_set_finalizer_f</code>函数来设置Dispatch Queue的finalizer，这个函数同时可以设置Dispatch Group和Dispatch Source的销毁函数（后面会讲到）。</p>

<pre><code>void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer);
</code></pre>

<h3>Dispatch Queue的上下文环境数据</h3>

<p>我们可以为每个Dispatch Queue设置一个自定义的上下文环境数据，调用<code>dispatch_set_context</code>来实现。同时我们也可以用<code>dispatch_get_context</code>获取这个上下文环境数据，这个函数同时可以设置Dispatch Group和Dispatch Source的上下文环境数据（后面会讲到）。</p>

<pre><code>void dispatch_set_context(dispatch_object_t object,void *context);
void * dispatch_get_context(dispatch_object_t object);
</code></pre>

<p>注意Dispatch Queue并不保证这个<code>context</code>不会释放，不会对它进行内存管理控制。我们需要自行管理<code>context</code>的内存分配和释放。一般我们非配内存设置<code>context</code>后，可以在finalizer里释放<code>context</code>占有的内存。</p>

<h2>并行执行循环</h2>

<p>在编程过程中，我们经常会用到<code>for</code>循环，而且<code>for</code>循环要做很多相关的任务。比如：</p>

<pre><code>for (i = 0; i &lt; count; i++) {
   //do a lot of work here.
   doSomething(i);
}
</code></pre>

<p>如果<code>for</code>循环中处理的任务是可并发的，显然放到一个线程中处理是很慢的，GCD提供两个函数<code>dispatch_apply</code>和<code>dispatch_apply_f</code>，<code>dispatch_apply</code>是用于Block的，而<code>dispatch_apply_f</code>可以用于c函数，它们可以替代可并发的<code>for</code>循环，来并行的运行而提高执行效率。</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(count, queue, ^(size_t i) {
   //do a lot of work here.
   doSomething(i);
});
</code></pre>

<h2>Dispatch Group</h2>

<p>有时候我们进行下一步操作，而这个操作需要等待几个任务处理完毕后才能继续，这时我们就需要用的Dispatch Group（类似thread join）。我们可以把若干个任务放到一个Dispatch Group中：</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{
   // Some asynchronous work
});
</code></pre>

<p><code>dispatch_group_async</code>跟<code>dispatch_async</code>一样，会把任务放到<code>queue</code>中执行，不过它比<code>dispatch_async</code>多做了一步操作就是把这个任务和<code>group</code>相关联。</p>

<p>把一些任务放到Dispatch Group后，我们就可以调用<code>dispatch_group_wait</code>来等待这些任务完成。若任务已经全部完成或为空，则直接返回，否则等待所有任务完成后返回。注意：返回后<code>group</code>会清空。</p>

<pre><code>dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
// Do some work after.
dispatch_release(group);
</code></pre>

<h2>Dispatch信号量</h2>

<p>很多程序设计都设计到信号量，生产者-消费者模型在多线程编程中会频繁的使用。GCD提供了自己的一套信号量机制。</p>

<p>信号量就是一些有限可数资源。比如打印机，假如系统有2台打印机，但同时有5个任务要使用打印机，那么只能有2个任务能同时进行打印，剩下3个要等待这2个任务打印完。那么程序工作过程应该是：任务首先获取打印机资源（<code>dispatch_semaphore_wait</code>），如果没有打印机可用了就要等待，直到其他任务用完这个打印机。当任务获取到打印机，就开始执行打印任务。任务用完打印机工作后，就必须把占用打印机释放（<code>dispatch_semaphore_signal</code>），以便其他任务可以接着打印。</p>

<pre><code>//创建资源的信号量，只创建一次，比如2台打印机，那么RESOURCE_SIZE为2.
dispatch_semaphore_t sema = dispatch_semaphore_create(RESOURCE_SIZE);

//如果任务使用一个资源时，使用前调用dispatch_semaphore_wait，用完后dispatch_semaphore_signal。
//下面的代码可能在多个线程中调用多次
dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);
//do some work here. the work will use one resource.
dispatch_semaphore_signal(sema);
</code></pre>

<p>信号量必须在资源使用之前调用<code>dispatch_semaphore_create</code>创建，而且只创建一次，<code>RESOURCE_SIZE</code>是可用资源的总数。使用资源时<code>dispatch_semaphore_wait</code>将资源的可用数减少一个，如果当前没有可用资源了，将会等待直到其他线程回收资源，即调用<code>dispatch_semaphore_signal</code>让可用资源增加。用完资源后调用<code>dispatch_semaphore_signal</code>回收可利用资源，资源可用数将增加一个。</p>

<p>如果是生产者-消费者模型的话，<code>RESOURCE_SIZE</code>可能最初为0，那么生产者将调用<code>dispatch_semaphore_signal</code>来产生一个单位的资源，消费者调用<code>dispatch_semaphore_wait</code>来消费（减少）一个单位的资源。当资源不足时，消费者会一直等待到资源数大于0，即生产者生成新的资源。<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<h2>Dispatch Source</h2>

<p>Dispatch Source是GCD中监听一些系统事件的有个Dispatch对象，它包括定时器、文件监听、进程监听、Mach port监听等类型。</p>

<p>可以通过<code>dispatch_source_create</code>创建一个Dispatch Source：</p>

<pre><code>dispatch_source_t dispatch_source_create(
   dispatch_source_type_t type,
   uintptr_t handle,
   unsigned long mask,
   dispatch_queue_t queue);
</code></pre>

<p>这里可以指定Dispatch Source的类型，<code>type</code>可以为文件读或写、进程监听等。<code>handle</code>为监听对象的句柄，如果是文件就是文件描述符，如果是进程就是进程ID。<code>mask</code>用来指定一些想要监听的事件，它的意义取决于<code>type</code>。<code>queue</code>指定事件处理的任务队列。</p>

<p>创建好Dispatch Source后，我们要为Dispatch Source设置一个事件处理模块。可以用<code>dispatch_source_set_event_handler</code>或<code>dispatch_source_set_event_handler_f</code>来设置：</p>

<pre><code>void dispatch_source_set_event_handler(
   dispatch_source_t source,
   dispatch_block_t handler);
</code></pre>

<p>设置好Dispatch Source后就可以调用<code>dispatch_resume</code>来启动监听。如果相应的事件发生就会触发事件处理模块。</p>

<p>同时我们也可以设置一个取消处理模块：</p>

<pre><code>dispatch_source_set_cancel_handler(mySource, ^{
   close(fd); // Close a file descriptor opened earlier.
});
</code></pre>

<p>取消处理模块会在Dispatch Source取消时调用。</p>

<p>下面介绍一下主要的Dispatch Source类型和示例代码。</p>

<h3>定时器</h3>

<p>定时器Dispatch Source可以每隔一个固定的时间处理一下任务。</p>

<pre><code>dispatch_source_t CreateDispatchTimer(uint64_t interval,
              uint64_t leeway,
              dispatch_queue_t queue,
              dispatch_block_t block)
{
   dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,
                                                     0, 0, queue);
   if (timer)
   {
      dispatch_source_set_timer(timer, dispatch_walltime(NULL, 0), interval, leeway);
      dispatch_source_set_event_handler(timer, block);
      dispatch_resume(timer);
   }
   return timer;
}

void MyCreateTimer()
{
   dispatch_source_t aTimer = CreateDispatchTimer(30ull * NSEC_PER_SEC,
                               1ull * NSEC_PER_SEC,
                               dispatch_get_main_queue(),
                               ^{ MyPeriodicTask(); });

   // Store it somewhere for later use.
    if (aTimer)
    {
        MyStoreTimer(aTimer);
    }
}
</code></pre>

<h4>dispatch_after和dispatch_after_f</h4>

<p>有时候我们只想处理一次延迟任务，可以用dispatch_after和dispatch_after_f</p>

<pre><code>void dispatch_after(
   dispatch_time_t when,
   dispatch_queue_t queue,
   dispatch_block_t block);
</code></pre>

<h3>监听文件事件</h3>

<p>监听文件事件分好几个类型，有读、写、属性的监听。</p>

<h4>读取文件</h4>

<pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, fd, 0, queue);
dispatch_source_set_event_handler(source, ^{
   // Get some data from the source variable, which is captured
   // from the parent context.
   size_t estimated = dispatch_source_get_data(source);
   // Continue reading the descriptor...
});
dispatch_resume(source);
</code></pre>

<h4>写文件</h4>

<pre><code>dispatch_source_t writeSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_WRITE,
                        fd, 0, queue);
if (!writeSource)
{
    close(fd);
    return NULL;
}

dispatch_source_set_event_handler(writeSource, ^{
    size_t bufferSize = MyGetDataSize();
    void* buffer = malloc(bufferSize);

    size_t actual = MyGetData(buffer, bufferSize);
    write(fd, buffer, actual);

    free(buffer);

    // Cancel and release the dispatch source when done.
    dispatch_source_cancel(writeSource);
});
</code></pre>

<h4>监听文件属性</h4>

<pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE,
            fd, DISPATCH_VNODE_RENAME, queue);
if (source)
{
  // Copy the filename for later use.
  int length = strlen(filename);
  char* newString = (char*)malloc(length + 1);
  newString = strcpy(newString, filename);
  dispatch_set_context(source, newString);

  // Install the event handler to process the name change
  dispatch_source_set_event_handler(source, ^{
        const char*  oldFilename = (char*)dispatch_get_context(source);
        MyUpdateFileName(oldFilename, fd);
  });

  // Install a cancellation handler to free the descriptor
  // and the stored string.
  dispatch_source_set_cancel_handler(source, ^{
      char* fileStr = (char*)dispatch_get_context(source);
      free(fileStr);
      close(fd);
  });

  // Start processing events.
  dispatch_resume(source);
}
else
  close(fd);
</code></pre>

<h3>监听进程事件</h3>

<p><code>DISPATCH_PROC_EXIT</code>是一个监听进程退出的类型。</p>

<pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC,
                                                  parentPID, DISPATCH_PROC_EXIT, queue);
if (source)
{
   dispatch_source_set_event_handler(source, ^{
     MySetAppExitFlag();
     dispatch_source_cancel(source);
     dispatch_release(source);
   });
   dispatch_resume(source);
}
</code></pre>

<h3>监听中断信号</h3>

<pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGHUP, 0, queue);
if (source)
{
  dispatch_source_set_event_handler(source, ^{
     MyProcessSIGHUP();
  });

  // Start processing signals
  dispatch_resume(source);
}
</code></pre>

<h2>参考文献</h2>

<ul>
<li>Dispatch Queues：<a href="https://developer.apple.com/library/mac/documentation/general/conceptual/concurrencyprogrammingguide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1">https://developer.apple.com/library/mac/documentation/general/conceptual/concurrencyprogrammingguide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW1</a></li>
<li>Dispatch Sources：<a href="https://developer.apple.com/library/mac/documentation/general/conceptual/concurrencyprogrammingguide/GCDWorkQueues/GCDWorkQueues.html">https://developer.apple.com/library/mac/documentation/general/conceptual/concurrencyprogrammingguide/GCDWorkQueues/GCDWorkQueues.html</a></li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>感谢Vincent Xue指出这里有些容易让新手迷糊的地方，我增加了一些关于信号量的说明，希望对新手能有所帮助。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C代码注释和文档输出的工具和方法]]></title>
    <link href="http://blog.xcodev.com/blog/2013/11/01/code-comment-and-doc-gen-tools-for-objc/"/>
    <updated>2013-11-01T01:31:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/11/01/code-comment-and-doc-gen-tools-for-objc</id>
    <content type="html"><![CDATA[<p>代码注释可以让代码更容易接受和使用，特别是在大型项目合作开发或模块开发中。Objective-C中也有一些很方便的注释插件和文档生成工具。本文推荐两个开源软件：VVDocumenter注释工具和appledoc文档生成工具。</p>

<!--more-->


<h2>VVDocumenter</h2>

<p>首先推荐一个Xcode插件<a href="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter</a>，它可以让我们在代码中快捷的插入通用的注释代码。</p>

<p><img src="https://raw.github.com/onevcat/VVDocumenter-Xcode/master/ScreenShot.gif" alt="image" /></p>

<p>有了这个插件只需要在要注释的方法定义前输入三个斜杠（///），它就会自动为我们生成注释模板，这些注释模板可以用文档输出工具输出为说明文档。</p>

<h3>下载和安装VVDocumenter</h3>

<p>VVDocumenter插件是github上的一个开源项目，地址是<a href="https://github.com/onevcat/VVDocumenter-Xcode">https://github.com/onevcat/VVDocumenter-Xcode</a>。你可以<code>git clone</code>或在github网站上下载工程的zip压缩文件。下载完成后，打开其中的工程，build&amp;run一下就安装成功了。然后记得要重新启动一下Xcode应用，VVDocumenter插件就生效了。试试在方法定义前输入“///”。</p>

<h2>appledoc</h2>

<p>我们开发自己的模块时，经常会将模块接口提供给别人使用，这样我们不得不写一些接口说明文档。很多语言都提供了这种工具比如javadoc，doxygen等，可以将注释代码转化成在线文档。这里推荐一个特别适合Objective-C语言的一种文档输出工具<a href="https://github.com/tomaz/appledoc">appledoc</a>。它可以把一些格式的注释转换成Apple SDK风格的文档，同时它支持VVDocumenter的输出注释格式。</p>

<h3>安装appledoc</h3>

<p>建议使用brew命令来安装，如果没有安装brew，可以先用一下命令安装一下：</p>

<pre><code>ruby -e "$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)"：
</code></pre>

<p>然后执行brew安装命令来安装appledoc</p>

<pre><code>brew install appledoc
</code></pre>

<h3>使用appledoc生成文档</h3>

<pre><code>appledoc [OPTIONS] &lt;paths to source dirs or files&gt;
</code></pre>

<p>该命令将生成并安装文档到Xcode，可以通过Xcode的文档浏览器来查看文档，并可以在Xcode中搜索到相关接口。</p>

<p><img src="http://blog.xcodev.com/images/post/xcode-doc-prev-apple-doc.png" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[并发编程之Operation Queue]]></title>
    <link href="http://blog.xcodev.com/blog/2013/10/28/operation-queue-intro/"/>
    <updated>2013-10-28T11:26:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/10/28/operation-queue-intro</id>
    <content type="html"><![CDATA[<p>随着移动设备的更新换代，移动设备的性能也不断提高，现在流行的CPU已经进入双核、甚至四核时代。如何充分发挥这些CPU的性能，会变得越来越重要。在iOS中如果想要充分利用多核心CPU的优势，就要采用并发编程，提高CPU的利用率。iOS中并发编程中主要有2种方式Operation Queue和GCD（Grand Central Dispatch）。下面就来先来说一下Operation Queue。</p>

<!--more-->


<h2>异步调用和并发</h2>

<p>在深入之前，首先说说异步调用和并发。这两个概念在并发编程中很容易弄混淆。异步调用是指调用时无需等待结果返回的调用，异步调用往往会触发后台线程处理，比如NSURLConnection的异步网络回调。并发是指多个任务（线程）同时执行。在异步调用的实现中往往采用并发机制，然而并不是所有异步都是并发机制，也有可能是其他机制，比如一些依靠中断进行的操作。</p>

<h2>为什么Operation Queue</h2>

<p>Operation Queue提供一个面向对象的并发编程接口，支持并发数，线程优先级，任务优先级，任务依赖关系等多种配置，可以方便满足各种复杂的多任务处理场景。</p>

<ul>
<li>面向对象接口</li>
<li>支持并发数配置</li>
<li>任务优先级调度</li>
<li>任务依赖关系</li>
<li>线程优先级配置</li>
</ul>


<h2>NSOperation简介</h2>

<p>iOS并发编程中，把每个并发任务定义为一个Operation，对应的类名是NSOperation。NSOperation是一个抽象类，无法直接使用，它只定义了Operation的一些基本方法。我们需要创建一个继承于它的子类或者使用系统预定义的子类。目前系统预定义了两个子类：NSInvocationOperation和NSBlockOperation。</p>

<h3>NSInvocationOperation</h3>

<p>NSInvoationOperation是一个基于对象和selector的Operation，使用这个你只需要指定对象以及任务的selector，如果必要，你还可以设定传递的对象参数。</p>

<pre><code>NSInvocationOperation *invacationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(doSomethingWithObj:) object:obj];
</code></pre>

<p>同时当这个Operation完成后，你还可以获取Operation中Invation执行后返回的结果对象。</p>

<pre><code>id result = [invacationOperation result];
</code></pre>

<h3>NSBlockOperation</h3>

<p>在一个Block中执行一个任务，这时我们就需要用到NSBlockOperation。可以通过<code>blockOperationWithBlock:</code>方法来方便地创建一个NSBlockOperation：</p>

<pre><code>NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
    //Do something here.
}];
</code></pre>

<h3>运行一个Operation</h3>

<p>调用Operation的<code>start</code>方法就可以直接运行一个Operation。</p>

<pre><code>[operation start];
</code></pre>

<p><code>start</code>方法用来启动一个Operation任务。同时，Operation提供一个<code>main</code>方法，你的所有任务都应该在main中进行处理。默认的<code>start</code>方法中会先做出一些异常判断然后直接调用<code>main</code>方法。如果需要自定义一个NSOperation必须重载<code>main</code>方法来执行你所想要执行的任务。</p>

<pre><code>@implementation CustomOperation

-(void)main {
   @try {
      // Do some work.
   }
   @catch(...) {
      // Exception handle.
   }
}
@end
</code></pre>

<h3>取消一个Operation</h3>

<p>要取消一个Operation，要向Operation对象发送cancel消息：</p>

<pre><code>[operation cancel];
</code></pre>

<p>当向一个Operation对象发送cancel消息后，并不保证这个Operation对象一定能立刻取消，这取决于你的<code>main</code>中对<code>cancel</code>的处理。如果你在<code>main</code>方法中没有对<code>cancel</code>进行任何处理的话，发送<code>cancel</code>消息是没有任何效果的。为了让Operation响应<code>cancel</code>消息，那么你就要在<code>main</code>方法中一些适当的地方手动的判断<code>isCancelled</code>属性，如果返回<code>YES</code>的话，应释放相关资源并立刻停止继续执行。</p>

<h3>创建可并发的Operation</h3>

<p>由于默认情况下Operation的<code>start</code>方法中直接调用了<code>main</code>方法，而<code>main</code>方法中会有比较耗时的处理任务。如果我们在一段代码连续<code>start</code>了多个Operation，这些Operation都是阻塞地依次执行完，因为第二个Operation必须等到第一个Operation执行完<code>start</code>内的<code>main</code>并返回。Operation默认都是不可并发的（使用了Operation Queue情况下除外，Operation Queue会独自管理自己的线程），因为默认情况下Operation并不额外创建线程。我们可以通过Operation的<code>isConcurrent</code>方法来判断Operation是否是可并发的。如果要让Operation可并发，我们需要让<code>main</code>在独立的线程中执行，并将<code>isConcurrent</code>返回YES。</p>

<pre><code>@implementation MyOperation{
    BOOL        executing;
    BOOL        finished;
}


- (BOOL)isConcurrent {
    return YES;
}

- (void)start {
   if ([self isCancelled])
   {
      [self willChangeValueForKey:@"isFinished"];
      finished = YES;
      [self didChangeValueForKey:@"isFinished"];
      return;
   }

   [self willChangeValueForKey:@"isExecuting"];
   [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];
   executing = YES;
   [self didChangeValueForKey:@"isExecuting"];
}

- (void)main {
   @try {
        // Do some work.

        [self willChangeValueForKey:@"isFinished"];
        [self willChangeValueForKey:@"isExecuting"];
        executing = NO;
        finished = YES;
        [self didChangeValueForKey:@"isExecuting"];
        [self didChangeValueForKey:@"isFinished"];

   }
   @catch(...) {
      // Exception handle.
   }
}

@end
</code></pre>

<p>当你自定义了<code>start</code>或<code>main</code>方法时，一定要手动的调用一些KVO通知方法，以便让对象的KVO机制可以正常运作。</p>

<h3>设置Operation的completionBlock</h3>

<p>每个Operation都可以设置一个<code>completionBlock</code>，在Operation执行完成时自动执行这个Block。我们可以在此进行一些完成的处理。<code>completionBlock</code>实现原理是对Operation的<code>isFinnshed</code>字段进行KVO（Key-Value Observing），当监听到<code>isFinnished</code>变成YES时，就执行<code>completionBlock</code>。</p>

<pre><code>operation.completionBlock = ^{
    NSLog(@"finished");
};
</code></pre>

<h3>设置Operation的线程优先级</h3>

<p>我们可以为Operation设置一个线程优先级，即<code>threadPriority</code>。那么执行<code>main</code>的时候，线程优先级就会调整到所设置的线程优先级。这个默认值是0.5，我们可以在Operation执行前修改它。</p>

<pre><code>operation.threadPriority = 0.1;
</code></pre>

<p>注意：如果你重载的<code>start</code>方法，那么你需要自己来配置<code>main</code>执行时的线程优先级和<code>threadPriority</code>字段保持一致。</p>

<h3>Operation状态变化</h3>

<p>我们可以通过KVO机制来监听Operation的一下状态改变，比如一个Operation的执行状态或完成状态。这些状态的keypath包括以下几个：</p>

<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>


<h2>NSOperationQueue</h2>

<p>NSOperationQueue是一个Operation执行队列，你可以将任何你想要执行的Operation添加到Operation Queue中，以在队列中执行。同时Operation和Operation Queue提供了很多可配置选项。Operation Queue的实现中，创建了一个或多个可管理的线程，为队列中的Operation提供可高度自定的执行环境。</p>

<h3>Operation的依赖关系</h3>

<p>有时候我们对任务的执行顺序有要求，一个任务必须在另一个任务执行之前完成，这就需要用到Operation的依赖（Dependency）属性。我们可以为每个Operation设定一些依赖的另外一些Operation，那么如果依赖的Operation没有全部执行完毕，这个Operation就不会被执行。</p>

<pre><code>[operation addDependency:anotherOperation];
[operation removeDependency:anotherOperation];
</code></pre>

<p>如果将这些Operation和它所依赖的Operation加如队列中，那么Operation只有在它依赖的Operation都执行完毕后才可以被执行。这样我们就可以方便的控制Operation执行顺序。</p>

<h3>Operation在队列中执行的优先级</h3>

<p>Operation在队列中默认是按FIFO（First In First Out）顺序执行的。同时我们可以为单个的Operation设置一个执行的优先级，打乱这个顺序。当Queue有空闲资源执行新的Operation时，会优先执行当前队列中优先级最高的待执行Operation。</p>

<h3>最大并发Operation数目</h3>

<p>在一个Operation Queue中是可以同时执行多个Operation的，Operation Queue会动态的创建多个线程来完成相应Operation。具体的线程数是由Operation Queue来优化配置的，这一般取决与系统CPU的性能，比如CPU的核心数，和CPU的负载。但我们还是可以设置一个最大并发数的，那么Operation Queue就不会创建超过最大并发数量的线程。</p>

<pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];
queue.maxConcurrentOperationCount = 1;
</code></pre>

<p>如果我们将<code>maxConcurrentOperationCount</code>设置为<code>1</code>，那么在队列中每次只能执行一个任务。这就是一个串行的执行队列了。</p>

<h3>Simple Code</h3>

<p>下面我写了一个简单的Simple Code来说明一下Operation和Operation Queue。</p>

<pre><code>NSBlockOperation *operation5s = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"operation5s begin");
    sleep(5);
    NSLog(@"operation5s end");
}];
operation5s.queuePriority = NSOperationQueuePriorityHigh;
NSBlockOperation *operation1s = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"operation1s begin");
    sleep(1);
    NSLog(@"operation1s end");
}];
NSBlockOperation *operation2s = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"operation2s begin");
    sleep(2);
    NSLog(@"operation2s end");
}];

operation1s.completionBlock = ^{
    NSLog(@"operation1s finished in completionBlock");
};

NSOperationQueue *queue = [[NSOperationQueue alloc] init];
queue.maxConcurrentOperationCount = 1;
[queue addOperation:operation1s];
[queue addOperation:operation2s];
[queue addOperation:operation5s];
[queue waitUntilAllOperationsAreFinished];
</code></pre>

<p>运行这段代码，我得到了一下输出结果：</p>

<pre><code>operation1s begin
operation1s end
operation5s begin
operation1s finished in completionBlock
operation5s end
operation2s begin
operation2s end
</code></pre>

<p>为了更好的展示队列优先级效果，我把queue的<code>maxConcurrentOperationCount</code>设置为<code>1</code>，以便任务一个一个的执行。从上面日志可以看出，第一个operation1s执行完毕后，会执行operation5s，而不是operation2s，因为operation5s的<code>queuePriority</code>是<code>NSOperationQueuePriorityHigh</code>。而第一个线程总是会第一个执行。在看看2-4行，我们可以看出operation1s的<code>completionBlock</code>比operation5s晚开始执行，说明它不在operation1s的线程中执行的。正如前面所说，<code>completionBlock</code>是通过KVO监听执行，一般会运行在监听所在线程，而不是Operation执行的线程。</p>

<h2>注意事项</h2>

<ul>
<li>当一个Operation被加入Queue中后，请不要对这个Operation再进行任何修改。因为一旦加入Queue，它随时就有可能会被执行，对它的任何修改都有可能导致它的运行状态不可控制。</li>
<li><code>threadPriority</code>仅仅影响了<code>main</code>执行时的线程优先级，其他的方法包括<code>completionBlock</code>都是以默认的优先级来执行的。如果自定义的话，也要注意在<code>main</code>执行前设置好<code>threadPriority</code>，执行完毕后要还原默认线程优先级。</li>
<li>经测试，Operation的<code>threadPriority</code>字段只有在Operation单独执行时有效，在Operation Queue中是无效的。</li>
<li>第一个加入到Operation Queue中的Operation，无论它的优先级有多么低，总是会第一个执行。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[64位与Tagged Pointer]]></title>
    <link href="http://blog.xcodev.com/blog/2013/10/21/tagged-pointer-and-64-bit/"/>
    <updated>2013-10-21T16:09:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/10/21/tagged-pointer-and-64-bit</id>
    <content type="html"><![CDATA[<p>在Mac OS X 10.6（Snow Leopard）中开始支持64位，如今最新版本iPhone 5s也开始采用了Arm64架构。在64位化的过程中，其中一个比较关键的改进就是，Mac OS 10.7（Lion）和iOS 7的64位环境先后引入了Tagged Pointer。下面就简单地来介绍一下Tagged Pointer，在介绍Tagged Pointer之前有必要介绍一下指针地址对齐概念和64位环境的一些变化。</p>

<!--more-->


<h2>指针地址对齐</h2>

<p>在32位环境下，如果要读取一个32位整数，如果这个32位整数在内存地址为0x00000002-0x00000006（仅作举例，这个地址一般是被系统保留的）的内存上，读取这个整数会消耗2个CPU周期，而如果这个数在0x00000004-0x00000008的内存上只需要一个CPU周期。为了加快内存的CPU访问，程序都使用了指针地址对齐概念。指针地址对齐就是指在分配堆中的内存时往往采用偶数倍或以2为指数倍的内存地址作为地址边界。几乎所有系统架构，包括Mac OS和iOS，都使用了地址对齐概念。</p>

<pre><code>void *a = malloc(1);
void *b = malloc(3);
NSLog(@"a: %p",a);
NSLog(@"b: %p",b);
</code></pre>

<p>运行这段代码后，我得到了如下结果：</p>

<pre><code>a: 0x8c11e20
b: 0x8c11e30
</code></pre>

<p>可以看到，a和b指针的最后4位都是0，虽然a只占用1个字节，但是a和b的地址却相差16个字节。因为iOS中是以16个字节为内存分配边界的，或者说iOS的指针地址对齐是以16个字节为对齐边界的。进一步说，iOS中分配的内存地址最后4位永远都是0。</p>

<h2>64位地址</h2>

<p>在不久前发布iPhone5s中采用了Arm64的CPU，同时也支持了64位的App。64位App中指针大小也扩大到64位，就是理论上可以支持最大2<sup>64</sup>字节（达千万T字节）的内存地址空间。而对于大多数应用来说，这么大的地址空间完全是浪费的。也就是说64位环境下，内存地址的前面很多位一般都是0。</p>

<h2>Tagged Pointer</h2>

<p>由于指针地址对齐概念和64位超大地址的出现，指针地址仅仅作为内存的地址是比较浪费的，我们可以在指针地址中保存或附加更多的信息。这就引入了Tagged Pointer概念。Tagged Pointer是指那些指针中包含特殊属性或信息的指针。其中指针对齐概念可以让我们来标识一个指针是否是Tagged Pointer以及相关类型，64位的地址指针又为我们提供保存额外信息的足够空间。如今，iOS 7的64位环境和Mac OS 10.7（Lion）中开始引入了Tagged Pointer。</p>

<h2>NSNumber的优化</h2>

<p>Tagged Pointer一个比较典型的应用就是NSNumber，在64位环境下，对于一般的数字，NSNumber不用再分配内存了。我们看看NSNumber是如何运用Tagged Pointer的：</p>

<pre><code>NSNumber *number3 = @3;
NSNumber *number4 = @4;
NSNumber *number9 = @9;
NSLog(@"number3 pointer is %p", number3);
NSLog(@"number4 pointer is %p", number4);
NSLog(@"number9 pointer is %p", number9);
</code></pre>

<p>在64位模拟器中运行后，我得到了如下结果：</p>

<pre><code>number3 pointer is 0xb000000000000032
number4 pointer is 0xb000000000000042
number9 pointer is 0xb000000000000092
</code></pre>

<p>可以看出<code>number3</code>、<code>number4</code>和<code>number9</code>的值前4位都是0xb，后4位都是0x2（指针的Tag），中间就是实际的取值，因此，这些NSNumber已经不需要再分配内存（指堆中内存）了，直接可以把实际的值保存到指针中，而无需再去访问堆中的数据。这无疑提高的内存访问速度和整体运算速度。</p>

<p>也就是说Tagged Pointer本身就可以表示一个NSNumber了，在64位环境下运行这段代码：</p>

<pre><code>NSLog(@"0xb000000000000052's class is %@",[(NSNumber*)0xb000000000000052 class]);
</code></pre>

<p>会输出下面结果：</p>

<pre><code>0xb000000000000052's class is __NSCFNumber
</code></pre>

<p>那么如果一个数超过了Tagged Pointer所能表示的范围，系统会怎么处理？看看这段代码：</p>

<pre><code>NSNumber *numberBig = @(0x1234567890ABCDEF);
NSLog(@"numberBig pointer is %p", numberBig);
</code></pre>

<p>在64位模拟器中运行后，我得到了如下结果：</p>

<pre><code>numberBig pointer is 0x1094026a0
</code></pre>

<p>可以看出<code>numberBig</code>指针最后4位都是0，应该是分配在堆中的对象。因此，如果NSNumber超出了Tagged Pointer所能表示的范围，系统会自动采用分配成对象，可以根据指针的最后4位是否为0来区分。</p>

<h2>isa指针优化</h2>

<p>查看NSObject类的头文件，你会发现这段定义：</p>

<pre><code>@interface NSObject &lt;NSObject&gt; {
    Class isa;
}
</code></pre>

<p>所有类都继承自NSObject，因此每个对象都有一个isa<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>指针指向它所属的类。在《<a href="http://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html">ARM64 and You</a>》文章中指出：</p>

<p>在32位环境下，对象的引用计数都保存在一个外部的表中，而对引用计数的增减操作都要先锁定这个表，操作完成后才解锁。这个效率是非常慢的。</p>

<p>而在64位环境下，isa也是64位，实际作为指针部分只用到的其中33位，剩余的部分会运用到Tagged Pointer的概念，其中19位将保存对象的引用计数，这样对引用计数的操作只需要原子的修改这个指针即可，如果引用计数超出19位，才会将引用计数保存到外部表，而这种情况往往是很少的，因此效率将会大大提高。</p>

<h2>参考文献</h2>

<ul>
<li>Objective-C对象模型及应用： <a href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/">http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/</a></li>
<li>ARM64 and You：<a href="http://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html">http://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html</a></li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>isa是“is a”，比如“Apple is a company”，表示一种从属关系。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客搬家到Octopress]]></title>
    <link href="http://blog.xcodev.com/blog/2013/10/16/start-using-octopress/"/>
    <updated>2013-10-16T22:26:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/10/16/start-using-octopress</id>
    <content type="html"><![CDATA[<p>之前一直在用Wordpress博客框架来写博客，一直没换过。但最近发现很多开发朋友都在使用Octopress，据说是一个面向黑客和开发者的博客，所以也跟风用上了Octopress。几经折腾终于把以前Wordpress的内容搬到了Octopress。</p>

<!--more-->


<h2>为什么用Octopress？</h2>

<p>Octopress同样也是一个开源的博客框架，它主要面向黑客和开发者。相比Wordpress，它具备以下优点。</p>

<ul>
<li>界面非常清晰简洁，更加突出内容而非风格。</li>
<li>它是一个静态的网页框架，运行加载速度更快。</li>
<li>使用Markdown语法来高效写文章，而无需关注一些杂乱的html格式</li>
<li>可以免费部署到github page</li>
<li>博客使用git进行版本控制</li>
</ul>


<p>但Octopress也有一些局限和不足。</p>

<ul>
<li>安装过程繁琐，比较麻烦</li>
<li>没有汉化（需要手动汉化）</li>
<li>评论需要外部支持</li>
<li>主题风格比较单一</li>
</ul>


<p>但这些并不是黑客和开发者的困难，目前有很多社会化评论和分享系统，稍微修改一下代码就可以很不错的支持Octopress。</p>

<h2>在Mac OS X下安装Octopress</h2>

<p>Octopress需要ruby开发环境，需要ruby 1.9.3版本，虽然Mac OS X自带的ruby（10.8带ruby 1.8，1.9自带ruby 2.0），但自带的ruby是给系统使用的，并不适合安装Octopress。所以我们要手动安装ruby 1.9.3版本。这就要我们使用rbenv或rvm来管理ruby的多版本。开始时我尝试使用rvm来管理，安装ruby 1.9.3版时它却自动给我安装macport。而macport安装超慢，我就放弃而采用rbenv。下面来看看我的安装步骤。安装rbenv我使用了brew工具来快速安装。</p>

<h4>1. 安装brew</h4>

<p>下载并安装brew。在终端输入并执行以下命令稍等片刻就好了。</p>

<pre><code>ruby -e "$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)"
</code></pre>

<h4>2. 安装rbenv</h4>

<p>安装rbenv需要配置一些环境变量，然后使用brew来安装。具体命令如下。</p>

<pre><code>cd
echo 'export PATH="$HOME/.rbenv/bin:$PATH"' &gt;&gt; ~/.bash_profile
echo 'eval "$(rbenv init -)"' &gt;&gt; ~/.bash_profile
source ~/.bash_profile
brew update
brew install rbenv
brew install ruby-build
</code></pre>

<h4>3. 安装ruby 1.9.3</h4>

<p>接着用rbenv来安装ruby 1.9.3-p125版（这个版本开始支持llvm编译器）。</p>

<pre><code>rbenv install 1.9.3-p125
rbenv rehash
</code></pre>

<h4>4. 建立Octopress</h4>

<p>从github上clone下来Octopress。</p>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
cd octopress
</code></pre>

<h4>5. 将当前ruby版本设置为1.9.3</h4>

<p>请确保当前目录是octopress目录，然后执行以下命令，将当前ruby版本设置为<code>1.9.3</code>。</p>

<pre><code>rbenv local 1.9.3-p125
</code></pre>

<p>查看当前本地ruby版本</p>

<pre><code>rbenv local
</code></pre>

<p>如果显示为<code>1.9.3-p125</code>，那么就是正确的。</p>

<h4>6. 安装依赖软件</h4>

<p>运行以下命令安装必须的gem。</p>

<pre><code>gem install bundler
rbenv rehash
bundle install
</code></pre>

<p>安装Octopress默认主题</p>

<pre><code>rake install
</code></pre>

<h4>7. 设置Github</h4>

<p>Octopress本身生成的是静态网页，是可以发布到很多网站的，支持自动发布Github Page。首先要在Github上申请一个名为<code>username.github.io</code>的代码仓库（<code>username</code>请替换为你的用户名）。</p>

<p>然后运行以下命令：</p>

<pre><code>rake setup_github_pages
</code></pre>

<p>输入必要的用户名密码信息就设置完成。</p>

<h4>8. 预览和发布</h4>

<p>你可以在本地生成网页并实时预览，执行以下命令：</p>

<pre><code>rake generate
rake preview
</code></pre>

<p>这会打开本地的4000端口，你可以在浏览器打开url: <code>http://localhost:4000/</code>来预览Octopress网站了。</p>

<p>要发布到github上，执行以下命令即可。</p>

<pre><code>rake generate
rake deploy
</code></pre>

<p>然后在浏览器中输入<code>http://username.github.io</code>就可以查看你的Octopress了。</p>

<h2>写文章</h2>

<p>执行以下命令可以生成一个简单的文章框架。</p>

<pre><code>rake new_post[your-english-article-name]
</code></pre>

<p>其中<code>your-english-article-name</code>将会作为文章url地址的一部分，请使用英文单词或拼音连接起来的字符串。这就在source/_posts目录下一个同名的markdown文件，编辑这个文件即可。写完后执行步骤8中的相关命令就可以查看和发布了。</p>

<h2>绑定域名</h2>

<p>在soure文件夹下建立一个名字为<code>CNAME</code>文件，文件的内容是你的域名地址，如<code>www.example.com</code>。然后将你的域名的CNAME指向<code>username.github.io</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用AppleScript在Mac系统下实现按键精灵的功能以及在游戏中的运用]]></title>
    <link href="http://blog.xcodev.com/blog/2013/08/15/auto-key-press-using-appscript/"/>
    <updated>2013-08-15T01:11:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/08/15/auto-key-press-using-appscript</id>
    <content type="html"><![CDATA[<h2>什么是AppleScript</h2>

<p>AppleScript是Mac系统提供的一个脚本语言，这个脚本语言简单易读，稍微懂一点脚本语言就可以快速学会了。AppleScript可以让我们的日常工作流程化，简化繁琐的固定输入，自动化完成一般的日常工作。
AppleScript提供了很多很多强大的功能，本文就只简单的介绍一下如何用它来实现类似Windows下按键精灵的功能。</p>

<!--more-->


<h2>前提工作</h2>

<p>如果想要让AppleScript自动帮我们按键，点击鼠标。首先还是要在设置里“启用辅助设备的控制”，否则AppleScript就没有权限控制我们的键盘、鼠标这些辅助设备。
打开“系统偏好设置”->“辅助功能”页面，然后勾选“启用辅助设备的控制”。</p>

<p><img src="http://blog.xcodev.com/images/post/enable-assist-device-control.png" alt="image" /></p>

<h2>如何按键</h2>

<p>在Mac系统中有个叫“System Events”的App，AppleScript可以让它做按键或者点击鼠标的动作。</p>

<pre><code>tell application "TextEdit"
    activate
end tell

tell application "System Events"
    tell process "TextEdit"
        set frontmost to true
    end tell

    key down shift
    keystroke "e"
    delay 1
    key up shift
    keystroke "e"
    keystroke return
end tell    
</code></pre>

<p>1-3行脚本用来运行系统自带App“文本编辑器”，第6-8行是将文本编辑器设置为前台App，这样我们的键盘鼠标消息才可以发到“文本编辑器”的进程上去。key down是按下某个按键不放，key up是松开某个按键，keystroke是点按一下某个按键。第10-13行相当与按shift+e，这样在文本编辑器中就输入的大写的“E”，然后14行就是又按了一下“e”，就紧接着输入了一个小写的“e”。15行按了一下回车，那么“文本编辑器”会换行。</p>

<h2>如何点击鼠标</h2>

<p>点击鼠标脚本和按键脚本类似，不同的是用了click at命令。如：</p>

<pre><code>tell application "System Events"
    tell process "xxx"
        set frontmost to true
    end tell
    click at {100,200}
end tell
</code></pre>

<p>这个脚本运行后就是在屏幕坐标点为{100,200}的地方点击一下鼠标左健。</p>

<h2>游戏《魔兽世界》中的运用</h2>

<p>做为一个爱玩游戏的技术宅，这些功能非常适合运用到游戏当中。所以，呵呵。一个运用就是防止暂离，《魔兽世界》战场中是不容许暂离的，一旦暂离就会被清除战场，如果你没节操挂机的话，就要每隔一段时间手动操作一下人物，比如按一下空格跳跃一下。使用以下这个脚本就可以在挂机的时候防止暂离了。</p>

<p>AntiAFK.scptd</p>

<pre><code>tell application "System Events"
    repeat while 1 is 1
        if UI elements enabled then
            tell process "World of Warcraft-64"
                set frontmost to true
            end tell
        end if
        keystroke " "
        delay (random number from 50 to 75)
    end repeat
end tell
</code></pre>

<p>这个脚本会每隔50-75秒，按一下空格跳跃一次。这样就不会有暂离状态了。之所以用随机50-75秒，是为了防止固定操作容易被反外挂程序检测到。</p>

<p>另外我还写一个刷地精声望的脚本</p>

<p>地精声望.scptd</p>

<pre><code>tell application "System Events"
    repeat while 1 is 1
        if UI elements enabled then
            tell process "World of Warcraft-64"
                set frontmost to true
            end tell
        end if
        keystroke "z"
        delay 2
        if UI elements enabled then
            tell process "World of Warcraft-64"
                set frontmost to true
            end tell
        end if
        keystroke "c"
        delay 2
        if UI elements enabled then
            tell process "World of Warcraft-64"
                set frontmost to true
            end tell
        end if
        keystroke "x"
        delay 2
        set r to (random number from 1 to 10)
        delay r
    end repeat
end tell
</code></pre>

<p>这个脚本是不停的按Z、X、C三个按键，可以根据情况绑定相应的技能。贫瘠之地有个勇士岛，岛上的一间屋子里有个叫“嘉维伊船长”的人，杀了他可以得到不少地精声望，而且他刷新很快，1-2分钟刷一次。这就让这个脚本来自动刷声望成为可能。
这个Z按键我绑定选目标攻击的WOW宏，WOW宏内容如下：</p>

<pre><code>/tar 嘉维伊船长
/startattack [exists,nodead]
</code></pre>

<p>X按键我绑定了公会战旗，这样就可以多得到点声望了。而且可以全程有战旗覆盖。
C按键我绑定了群体攻击大技能，这样就可以在群体技能冷却后杀死额外的小怪收获额外的声望。
然后，你要走到“嘉维伊船长”的刷新点面对他后运行脚本，这样就可以睡觉刷声望了。虽然效率不是很高，但缺很省心，毫不费劲，最重要的是不占用我们的时间。毕竟“时间就是金钱，我的朋友。”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C语言在Category中实现属性]]></title>
    <link href="http://blog.xcodev.com/blog/2013/08/14/implement-objc-property-in-category/"/>
    <updated>2013-08-14T10:43:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/08/14/implement-objc-property-in-category</id>
    <content type="html"><![CDATA[<p>做开发时我们常常会需要在已经实现了的类中增加一些方法，这时候我们一般会用Category的方式来做。但是这样做我们也只能扩展一些方法，而有时候我们更多的是想给它增加一个属性。由于类已经是编译好的了，就不能静态的增加成员了，这样我们就需要自己来实现getter和setter方法了，在这些方法中动态的读写属性变量来实现属性。一种比较简单的做法是使用Objective-C运行时的这两个方法：</p>

<pre><code>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
id objc_getAssociatedObject(id object, const void *key);
</code></pre>

<!--more-->


<p>这两个方法可以让一个对象和另一个对象关联，就是说一个对象可以保持对另一个对象的引用，并获取那个对象。有了这些，就能实现属性功能了。
policy可以设置为以下这些值：</p>

<pre><code>enum {
    OBJC_ASSOCIATION_ASSIGN = 0,
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
    OBJC_ASSOCIATION_RETAIN = 01401,
    OBJC_ASSOCIATION_COPY = 01403
};
</code></pre>

<p>这些值跟属性定义中的nonatomic，copy，retain等关键字的功能类似。</p>

<h2>Example</h2>

<p>下面是一个属性自定义getter和setter的例子：</p>

<pre><code>NSString const * kExposeController = @"exposeController";

- (UIViewController *)exposeController {
    return (UIViewController *)objc_getAssociatedObject(self, kExposeController);
}

- (void)setExposeController:(UIViewController *)exposeController {
    objc_setAssociatedObject(self, kExposeController, exposeController, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
</code></pre>

<p>可以看出使用objc_setAssociatedObject和objc_getAssociatedObject函数可以很方便的实现属性的getter和setter。</p>

<h2>一个很方便的宏</h2>

<p>为此，我特意写了一个Synthesize宏，可以提供@synthesize类似的功能。可以支持两种最常用的属性：非原子retain和assign属性（如果需要其他类型的属性可自行修改）。</p>

<pre><code>#import &lt;objc/runtime.h&gt;
#define SYNTHESIZE_CATEGORY_OBJ_PROPERTY(propertyGetter, propertySetter)                                                             
- (id) propertyGetter {                                                                                                             
    return objc_getAssociatedObject(self, @selector( propertyGetter ));                                                             
}                                                                                                                                   
- (void) propertySetter (id)obj{                                                                                                    
    objc_setAssociatedObject(self, @selector( propertyGetter ), obj, OBJC_ASSOCIATION_RETAIN_NONATOMIC);                            
}


#define SYNTHESIZE_CATEGORY_VALUE_PROPERTY(valueType, propertyGetter, propertySetter)                                                
- (valueType) propertyGetter {                                                                                                      
    valueType ret = {0};                                                                                                                  
    [objc_getAssociatedObject(self, @selector( propertyGetter )) getValue:&amp;ret];                                                    
    return ret;                                                                                                                     
}                                                                                                                                   
- (void) propertySetter (valueType)value{                                                                                           
    NSValue *valueObj = [NSValue valueWithBytes:&amp;value objCType:@encode(valueType)];                                                
    objc_setAssociatedObject(self, @selector( propertyGetter ), valueObj, OBJC_ASSOCIATION_RETAIN_NONATOMIC);                       
}
</code></pre>

<p>用这个宏只需要指定相关属性的类型，getter和setter就可以快速的实现一个属性。比如在UIAlert的Category实现一个非原子retain属性userInfo，以及一个assign的类型为CGRect的customArea属性：</p>

<p>UIAlertView+Ex.h</p>

<pre><code>@interface UIAlertView (Ex)
@property(nonatomic, retain) id userInfo;
@property(nonatomic) CGRect customArea;
@end
</code></pre>

<p>UIAlertView+Ex.m</p>

<pre><code>@implementation UIAlertView (Ex)
SYNTHESIZE_CATEGORY_OBJ_PROPERTY(userInfo, setUserInfo:)
SYNTHESIZE_CATEGORY_VALUE_PROPERTY(CGRect, customArea, setCustomArea:)
@end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS5网页视图（UIWebView）中的输入框不能弹出键盘的问题]]></title>
    <link href="http://blog.xcodev.com/blog/2013/07/30/no-keyboard-in-webview-of-ios5/"/>
    <updated>2013-07-30T10:32:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/07/30/no-keyboard-in-webview-of-ios5</id>
    <content type="html"><![CDATA[<p>项目开发时，发现有时候在网页视图中的输入框获得焦点后，却不能弹出键盘。而且全部都是在iOS5的系统中出现了这个问题，iOS6中运行完全是正常的，而且即使是在iOS5中，其他的UITextView和UITextField仍然可以正常地弹出键盘。我仔细了看了一下代码，发现对UIWebView的一些操作和键盘弹出并没有什么关系。我看了一些UIWebView的一些资料，然后发现了这个问题：UIWebView要能弹出键盘，那么它所在的window必须是key window。</p>

<!--more-->


<h2>什么是key window？</h2>

<p>key window就是接收键盘消息的window。键盘消息都会发送到key window上。而这个key window往往是系统自动设置的，但web view获得焦点并没有自动设置（也许是Apple开发偷了个懒），然而我们也可以用一个方法手动设置。</p>

<pre><code>[window makeKeyAndVisiable]
</code></pre>

<h2>一个演示例子</h2>

<p>为了验证这个问题我也写了一段简短的代码：</p>

<pre><code>UIWebView *webView = [[UIWebView alloc] initWithFrame:self.window.bounds];
[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.google.com"]]];
[self.window addSubview:webView];

UIWindow *anotherWindow = [UIWindow new];
[anotherWindow makeKeyAndVisible];
</code></pre>

<p>这段代码在iOS5中运行的话，即使输入框获得了焦点也不能弹出键盘。
<img src="http://blog.xcodev.com/images/post/no-keyboard-in-webview.jpg" alt="image" /></p>

<h2>解决方案</h2>

<p>如果在UIWebView被添加的window上时，将window设置为key window就好了。</p>

<pre><code>[self.window makeKeyAndVisiable]
[self.window addSubview:webView];
</code></pre>

<h2>小结</h2>

<p>UIWebView要能弹出键盘，那么它所在的window必须是key window。如果你的App可能存在多个Window（如弹出自定义的Alert，状态条等），而且这些window有可能被设置为key window，一定要在web view显示时将它所在的window设置为key window。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TableView中嵌套一个ScrollView有时导致ScrollView无法滚动]]></title>
    <link href="http://blog.xcodev.com/blog/2013/07/17/cant-scroll-in-tableview/"/>
    <updated>2013-07-17T15:34:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/07/17/cant-scroll-in-tableview</id>
    <content type="html"><![CDATA[<h2>TableView中嵌套ScrollView导致ScrollView无法滚动</h2>

<p>开发时，经常会在一个TableView中嵌套一个横向滚动ScrollView，当ScrollView进行滑动时，TableView中展示的信息也会需要相应的改变，那么有时就需要重新载入TableView的数据（reloadData）。这时当ScrollView连续滚动多次，经常会出现ScrollView滚动不了。在控制台上同时会出现以下日志信息：</p>

<pre><code>Ignoring call to [UIPanGestureRecognizer setTranslation:inView:] since gesture recognizer is not active.
</code></pre>

<!--more-->


<p>在QQ电影票新版开发过程中就遇到了这个问题。</p>

<p><img src="http://blog.xcodev.com/images/post/scrollView_in_tableView.jpg" alt="image" /></p>

<p>中间显示电影列表的是一个ScrollView。滑动过程中，如果中间箭头所指向的电影发生变化，整个界面信息就会刷新，调用TableView的reloadData。经过几次连续不间断的滑动电影列表后，就会导致ScrollView卡住，然后控制台就会出现“Ignoring call to [UIPanGestureRecognizer setTranslation:inView:] since gesture recognizer is not active.”的错误日志。</p>

<h2>原因分析</h2>

<p>开始时我以为是我自定义的ScrollView控件有问题，尝试各种屏蔽代码的方法，结果只有屏蔽的delegate的方法才不会出现问题，应该是delegate中的某些调用出现了问题。我仔细的检查了一下delegate方法，发现和TableView有关的一句代码：</p>

<pre><code>[self.tableView reloadData];
</code></pre>

<p>当我把reloadData注释调时，发现滑动起来很流畅，也没有出现这个问题了。可以断定时滑动过程中reloadData导致。结合错误日志，所以应该是滑动时同时reloadData，导致ScrollView的滑动手势失效。</p>

<h2>解决办法</h2>

<p>因为是在ScrollView的delegate消息中去调tableView的reloadData，可能在ScrollView的delegate消息处理完成之后，系统还会做一些其他的处理，这是你突然reloadData会导致ScrollView移出superView，然后导致滑动手势失效，所以我尝试异步调用一下TableView的reloadData：</p>

<pre><code>dispatch_async(dispatch_get_main_queue(), ^{
     [self.tableView reloadData];
});
</code></pre>

<p>结果果然没有问题了。其实我觉得更好的做法是直接将delegate消息调用写成异步调用会更好一些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 5中使用UIAppearance来自定义应用的外观]]></title>
    <link href="http://blog.xcodev.com/blog/2013/06/12/custom-ui-using-uiappearance/"/>
    <updated>2013-06-12T16:31:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/06/12/custom-ui-using-uiappearance</id>
    <content type="html"><![CDATA[<p>做App时，我们经常需要自定义一些界面展现，来适合我们App的内容，或来使App看起来更漂亮，有时我们不得不写大量的自定义控件来达到这个目的。iOS 5新增了UIAppearance协议，使得自定义风格简单方便了很多，通过UIAppearance协议，我们快速的修改系统内置的控件的外观，也可以自己定义一些可自定义外观的控件。</p>

<!--more-->


<h2>系统框架控件的一些自定义方法</h2>

<h4>自定义导航条背景</h4>

<pre><code>[[UINavigationBar appearance] setBackgroundImage:[UIImage imageNamed:@"background"] forBarMetrics:UIBarMetricsDefault];
</code></pre>

<h4>自定义导航标题文字属性</h4>

<pre><code>[[UINavigationBar appearance] setTitleTextAttributes:@{UITextAttributeTextColor:[UIColor darkGrayColor],UITextAttributeTextShadowColor:[UIColor clearColor]}];
</code></pre>

<p>可自定义标题字体，颜色，阴影。</p>

<h4>自定义导航条返回和左右按钮按钮背景</h4>

<pre><code>[[UIBarButtonItem appearanceWhenContainedIn:[UINavigationBar class], nil] setBackButtonBackgroundImage:[UIImage imageNamed:@"back_button_background"] forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];
[[UIBarButtonItem appearanceWhenContainedIn:[UINavigationBar class], nil] setBackgroundImage:[UIImage imageNamed:@"button_background"] forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];
</code></pre>

<h4>自定义底部Tab条的背景</h4>

<pre><code>[[UITabBar appearance] setBackgroundImage:[UIImage imageNamed:@"background"]];
</code></pre>

<h4>自定义底部条标题文字属性</h4>

<pre><code>[[UITabBarItem appearance] setTitleTextAttributes:@{UITextAttributeTextColor:[UIColor grayColor]} forState:UIControlStateNormal];
[[UITabBarItem appearance] setTitleTextAttributes:@{UITextAttributeTextColor:[UIColor orangeColor]} forState:UIControlStateSelected];
</code></pre>

<p>这里列举的都是一些最常用的自定义方法，只要是头文件中有“UI_APPEARANCE_SELECTOR”标记的方法都是可以用UIAppearance协议对象去调的。注意这些自定义方法都要在相应的对象显示之前调用，可以放到App启动后立刻配置，以后只要这个对象显示之前，就会设置相应的属性。</p>

<h2>自己创建一个可自定义外观的控件</h2>

<p>对于我们自己定义的控件，也可以支持UIAppearance协议，这样我们的控件也能支持自定义了。你只需要写一个设置外观的settor，然后在settor方法后面加上“UI_APPEARANCE_SELECTOR”标记就可以，其他什么都不需要做。比如一个可以自定义选择状态背景颜色的TableViewCell。</p>

<pre><code>@interface CustomCell : UITableViewCell
- (void)setSelectedBackgroundColor:(UIColor*)color UI_APPEARANCE_SELECTOR;
@end

@implementation CustomCell
- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
    if (self) {
        self.selectedBackgroundView = [UIView new];
        self.selectedBackgroundView.backgroundColor = [UIColor lightGrayColor];
    }
    return self;
}
- (void)setSelectedBackgroundColor:(UIColor*)color{
    self.selectedBackgroundView.backgroundColor = color;
}
@end
</code></pre>

<p>注意，官方文档中强调Appearance的setter定义格式应为：</p>

<pre><code>- (void)setProperty:(PropertyType)property forAxis1:(IntegerType)axis1 axis2:(IntegerType)axis2 axisN:(IntegerType)axisN;
- (PropertyType)propertyForAxis1:(IntegerType)axis1 axis2:(IntegerType)axis2 axisN:(IntegerType)axisN;
</code></pre>

<h2>UIAppearance实现原理</h2>

<p>在通过UIAppearance调用“UI_APPEARANCE_SELECTOR”标记的方法来配置外观时，UIAppearance实际上没有进行任何实际调用，而是把这个调用保存起来（在Objc中可以用NSInvocation对象来保存一个调用）。当实际的对象显示之前（添加到窗口上，drawRect:之前），就会对这个对象调用之前保存的调用。当这个setter调用后，你的界面风格自定义就完成了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix系统中设置文件的扩展属性]]></title>
    <link href="http://blog.xcodev.com/blog/2013/06/05/extented-file-property-in-unix/"/>
    <updated>2013-06-05T10:03:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/06/05/extented-file-property-in-unix</id>
    <content type="html"><![CDATA[<p>Unix文件系统中对单个文件提供了很多属性，比如创建时间、文件大小、修改时间等，这些信息都保存在文件系统中的inode节点中，获取这些属性并不需要读取文件，所以获取速度是很快的。在开发过程中常常会使用这些属性，但更多的时候我们需要一个自定义的属性，来保存我们需要的一些值。比如我们给文件定义一个有效期，或者给文件加一个特殊标记等。</p>

<!--more-->


<h2>解决方法</h2>

<p>我们可以建立一个数据库，每个文件为一条数据，再自定义一些字段，然而这样做会有些同步问题，比如文件不小心被删除了，或者文件名字改了，这会导致数据库操作过于复杂；或者我们在文件中添加一些自定义内容，加入文件的特定部分，但这样每次获取这些属性时都要读取这个文件，开销代价很高。</p>

<!--more-->


<p>其实Unix系统中提供了文件扩展属性的功能，可以非常方便的实现为文件添加自定义属性，这些属性会保存到文件节点数据中。如果文件删除了，这些数据也同时删除；如果文件改名了，也不会影响节点数据，因此这些属性依然会和改名后的文件关联；同时获取这些属性也不用去读取文件。设置一个自定义属性需要用到:</p>

<pre><code>int setxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options);
int fsetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options);
</code></pre>

<p>这两个函数都是用来设置一个文件的扩展属性，唯一的区别是其中setxattr第一个参数是文件路径，而fsetxattr是已打开的文件描述符（由open/creat函数返回）。name是指定的属性的名字，是一个c字符串，为了保证名字的唯一性，建议使用反域名格式的名字，如“com.example.propertyname”。第三个参数value是值的地址，第四个参数size是值的大小，position设置为0。options可以有以下几个：</p>

<ul>
<li>XATTR_NOFOLLOW 不跟随符号链接，如果文件是符号链接的话，设置这个option后会设置符号链接本身的属性，而不是符号链接所指向的文件的。</li>
<li>XATTR_CREATE 只能创建标志，如果文件已经有同名属性，则返回失败。</li>
<li>XATTR_REPLACE 只能替换标志，如果文件没有同名属性，则返回失败。</li>
</ul>


<p>成功后这两个函数会返回0；否则返回-1，同时设置了系统的errno。
同时Unix还提供了相应的获取已设置扩展属性的方法：</p>

<pre><code>ssize_t getxattr(const char *path, const char *name, void *value, size_t size, u_int32_t position, int options);
ssize_t fgetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options);
</code></pre>

<p>参数和设置方法的对应，只是传入的size是value的内存空间，返回的是值实际的大小。</p>

<h2>具体用法</h2>

<p>设置文件的过期日期</p>

<pre><code>NSDate *expireDate = ...;
const char* cfilePath = [filePath fileSystemRepresentation];
const char* attrExpireDate = "com.xcodev.file.expireDate";
double attrDate = [expireDate timeIntervalSince1970];
setxattr(cfilePath, attrExpireDate, &amp;attrDate, sizeof(attrDate), 0, 0);
</code></pre>

<p>获取文件过期日期，如果过期了就删除。</p>

<pre><code>const char* cfilePath = [path fileSystemRepresentation];
const char* attrExpireDate = "com.xcodev.file.expireDate";
double expireTimestamp = 0;
if (getxattr(cfilePath, attrExpireDate, &amp;expireTimestamp, sizeof(expireTimestamp), 0, 0)&gt;0) {
      NSDate *expireDate = [NSDate dateWithTimeIntervalSince1970:expireTimestamp];
      if ([expireDate compare:[NSDate date]]==NSOrderedAscending) {
            [[NSFileManager defaultManager] removeItemAtPath:path error:NULL];
      }
}
</code></pre>

<h2>Do not Backup</h2>

<p>文件扩展属性的另一个在iOS中的具体应用就是设置不让iCould备份标记。</p>

<pre><code>const char* cfilePath = [filePath fileSystemRepresentation];
const char* attrBackup = "com.apple.MobileBackup";
u_int8_t attrValue = 1;
setxattr(cfilePath, attrBackup, &amp;attrValue, sizeof(attrValue), 0, 0);
</code></pre>

<p>把“com.apple.MobileBackup”的值设置为1后，iCloud就不再去备份这个文件了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C中方法签名(Method Signature)机制]]></title>
    <link href="http://blog.xcodev.com/blog/2013/05/30/method-signature-in-objc/"/>
    <updated>2013-05-30T15:23:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/05/30/method-signature-in-objc</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在ObjC语言中，我们会自定义各种各样的类，在类定义中，我们又会定义各种方法，当方法达到一定的数量，有时会不可避免的出现一些同名的方法。而同名的方法有时会导致运行时出现很奇怪的问题。比如传递参数不一致时，出现运行时错误。这些都和ObjC中的方法签名（Method Signature）相关。</p>

<!--more-->


<h2>什么是方法签名</h2>

<p>方法签名是ObjC中对一个方法的参数类型和返回值类型的一条记录。每个方法都对应一个方法签名。</p>

<h2>一些基本概念</h2>

<p>有几个名词在深入理解方法签名机制之前必须区分清楚：
部分可参考我之前的一篇博文：
<a href="http://blog.xcodev.com/blog/2012/03/22/difference-between-message-and-method/">Objective-C中消息（Message）和方法（Method）的区别</a></p>

<h3>消息</h3>

<p>消息由消息的名字和参数组成，可以有返回值，用于发送给某个对象。大部分我们写的代码都是向一个对象发送消息。比如：</p>

<pre><code>[receiver message];
</code></pre>

<h3>方法</h3>

<p>方法对应一段可执行代码，是implementation的一部分。当我们向某个对象发送消息时，系统会分析我们所发送的消息，动态地调用响应的方法。对应ObjC中的IMP类型。</p>

<h3>Selector</h3>

<p>ObjC中有个SEL类型，这个类型就是Selector的类型。我们可以用@selector操作符来获取一个Selector。Selector可理解为方法的名字，但这并不包含参数和返回值，仅仅是名字。你还需注意，Selector不和任何类关联，你不能说某个Selector属于一个类，它仅仅是名字。</p>

<h2>NSMethodSignature类</h2>

<p>ObjC中有一个NSMethodSignature类，这个类很好的帮助我们来分析一下ObjC中的方法签名机制，这个类中定义了以下几个方法</p>

<pre><code>- (NSUInteger)numberOfArguments;//参数的数量
- (const char *)getArgumentTypeAtIndex:(NSUInteger)idx;//第idx个参数的类型
- (const char *)methodReturnType;//返回值类型
- (NSUInteger)methodReturnLength;//返回值长度，单位字节
</code></pre>

<p>从这些定义中我们可以看出，方法签名中会包含方法的参数个数，每个参数的类型，返回值类型，以及返回值占用的空间大小。
NSObject基类中提供了获取这个对象的方法</p>

<pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
</code></pre>

<p>所以，只要知道一个对象，和一个SEL（selector），那么就可以动态的获取这个方法签名了。</p>

<h2>参数类型签名不同导致的一个奇怪现象</h2>

<p>下面先举个例子，来看看参数类型签名不同导致的一个奇怪现象。
首先我们定义两个类，两个类是继承关系，但定义了同名的方法，但方法的参数类型不同。（所以它们的方法签名是不同的。）</p>

<pre><code>//基类
@interface ParamBase : NSObject
- (void)doSomeThing:(int)i;
@end

@implementation ParamBase
- (void)doSomeThing:(int)i{
    NSLog(@"Base doSomeThing called with int: %d",i);
}
@end

//子类
@interface ParamSub : ParamBase
- (void)doSomeThing:(double)d;
@end

@implementation ParamSub
- (void)doSomeThing:(double)d{
    NSLog(@"Sub doSomeThing called with double: %f",d);
}
@end
</code></pre>

<p>然后，我们创建个子类对象，然后分别在不同情况下执行doSomeThing，我们都传递相同的参数。</p>

<pre><code>ParamBase *a = [ParamSub new];
[a doSomeThing:1.0];
[(ParamSub*)a doSomeThing:1.0];
</code></pre>

<p>然后运行，你会得到如下结果。</p>

<pre><code>2013-05-30 14:25:03.242 MethodSignTest[2144:c07] Sub doSomeThing called with double: 0.000000
2013-05-30 14:25:03.244 MethodSignTest[2144:c07] Sub doSomeThing called with double: 1.000000
</code></pre>

<p>向一个对象发送了相同的消息，并且参数相同，为什么两次得到的结果不同。明明发送了1，为什么确变成0了。这其实是方法签名在编译阶段时捣鬼。当编译第二行代码时，编译器发现ParamBase对象的doSomeThing方法签名中的第一个参数是int类型，虽然代码了写的是1.0，但编译后就转换整数1了。运行时在子类的doSomeThing把整数1强制以double类型打印出来就是0了。而第3行代码就没有问题。应为编译器已经知道a已强制为ParamSub类型，而ParamSub对象doSomeThing方法签名中的第一个参数是double类型，而不是int类型，所以就没问题了。</p>

<h2>在ARC（自动引用计数机制）下返回值类型签名不同导致Crash</h2>

<p>我们再定义两个类，两个类还是继承关系，定义了同名的方法，但方法的返回值类型不同。（所以它们的方法签名也是不同的。）</p>

<pre><code>//基类
@interface ReturnBase : NSObject
- (id)getSomeThing;
@end

@implementation ReturnBase
- (id)getSomeThing{
    NSLog(@"Return Base called");
    return [NSArray new];
}
@end

//子类
@interface ReturnSub : ReturnBase
- (void)getSomeThing;
@end

@implementation ReturnSub
- (void)getSomeThing{
    NSLog(@"nothing");
}
@end
</code></pre>

<p>然后我们执行下面这段代码：</p>

<pre><code>ReturnBase *b = [ReturnSub new];
[(ReturnSub*)b getSomeThing];
[b getSomeThing];
</code></pre>

<p>结果程序在第3行Crash了，Crash类型一般是内存访问（BAD ACCESS）错误。第2行和第3行在ObjC动态绑定的机制下完全是相同的代码啊，为什么第2行没Crash，到第3行就Crash了呢？这是由于ARC和方法签名机制共同作用的结果，ARC下系统会对消息的返回值自动做一些retain或release等操作，而b在运行时ReturnSub类型，getSomeThing是不返回任何对象的。第二行时编译器知道b是ReturnSub类型，所以不会处理返回值了，而在第3行时，编译器认为b是ReturnBase类型，而根据ReturnBase类的方法getSomeThing的签名，是有返回值的，所以第3行编译后会自动对getSomeThing的返回值加一些retain/release等操作，而运行时却是没有返回值的（void类型），那么返回值就是不确定的，对这个不确定的值进行retain/release操作，一般就会导致内存访问（BAD ACCESS）错误。
也许你会想，我如果把b设为id类型，会怎样。</p>

<pre><code>id b = [ReturnSub new];
[(ReturnSub*)b getSomeThing];
[b getSomeThing];
</code></pre>

<p>结果是编译不通过，名字为getSomeThing的方法的签名不一致，编译器就不知道有没有返回值了。</p>

<h2>结论</h2>

<p>方法签名在编译时对方法的参数进行一定的转换。
ARC下会根据方法签名中的返回值进行retain/release等操作
最好不要写方法名字相同，当方法签名不同的方法，以免出现怪异现象。
有时我们改变了一个基类的参数类型或返回值类型，不要忘记了在子类中进行相应的修改。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIAlertView弹出视图动画效果]]></title>
    <link href="http://blog.xcodev.com/blog/2013/04/10/uialertview-animation/"/>
    <updated>2013-04-10T22:01:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/04/10/uialertview-animation</id>
    <content type="html"><![CDATA[<p>在App设计中为了加强用户体验，我们会常常加入一些友好的动画效果。比如类似UIAlertView弹出的动画效果，由于系统中并没有直接提供类似的动画API，如果我们想要做出一样的效果，那就得深入的研究一下系统中的UIAlertView了。</p>

<p>仔细观察UIAlertView的动画你就会发现：这个动画是由几部分组成，它带一个视图大小抖动的效果。先是由小变大，再由大变小，最后变成本来的大小。但是这个大小的具体参数值和动画的速度恐怕是肉眼所不能看出来的。
本篇文章会使用一些objc runtime和CAAnimation的一些知识，通过本文你可以了解到如何研究一些objc中内部调用机制和动画基础。</p>

<!--more-->


<p>要想知道这些动画的组成，我们就要从比较低层次的API：CALayer的一些调用开始。iOS动画最终都是加到Layer中的，加入Layer就要调用Layer对象这个方法：</p>

<pre><code>- (void)addAnimation:(CAAnimation *)anim forKey:(NSString *)key;
</code></pre>

<p>所以只要我们知道了anim参数，并把anim动画对象的属性揪出来，就可以知道到底是什么动画了，但是这个方法是系统Framework中的，通常我们是无法能知道anim到底是什么。这时我们就需要用一些objc的一些底层API：Objc Runtime来解决了。</p>

<h2>Objc Runtime</h2>

<p>Objc Runtime是由一组处理Objctive-C动态语言运行时的API函数组成，这些函数都是一些比较底层的C函数。它有很多实用功能比如查看对象的成员，类/对象方法签名等等。这次我们要用的就是其中把对象方法调用替换的API。</p>

<pre><code>void method_exchangeImplementations(Method m1, Method m2) 
</code></pre>

<p>这个函数的功能就是把类/对象的方法m1和m2进行调换。如果执行了这个函数，那么在App运行过程中所有调用方法m1的指令，最终都会执行成了方法m2。</p>

<h2>方法调换</h2>

<p>有了Objc Rumtime的API，就可以很方便的将调用系统库中方法的代码，执行成我们自己的代码了。所以我们想要知道Layer中加入了什么方法，只要把addAnimation:forKey:这个方法调换成我们自己的方法就行了。下面的这段代码就实现了这个功能。</p>

<pre><code>@implementation CALayer(Hacked)

+ (void)load{
    method_exchangeImplementations(class_getInstanceMethod([CALayer class], @selector(addAnimation:forKey:)), class_getInstanceMethod([CALayer class], @selector(hackedAddAnimation:forKey:)));
}

- (void)hackedAddAnimation:(CABasicAnimation *)anim forKey:(NSString *)key{
    [self hackedAddAnimation:anim forKey:key];
    if ([anim isKindOfClass:[CABasicAnimation class]]) {
        if ([anim.keyPath isEqualToString:@"transform"]) {
            if (anim.fromValue) {
                CATransform3D fromValue = [anim.fromValue CATransform3DValue];
                NSLog(@"From:%@",NSStringFromCGAffineTransform(CATransform3DGetAffineTransform(fromValue)));
            }
            if (anim.toValue) {
                CATransform3D toValue = [anim.toValue CATransform3DValue];
                NSLog(@"To:%@",NSStringFromCGAffineTransform(CATransform3DGetAffineTransform(toValue)));
            }
            if (anim.byValue) {
                CATransform3D byValue = [anim.byValue CATransform3DValue];
                NSLog(@"By:%@",NSStringFromCGAffineTransform(CATransform3DGetAffineTransform(byValue)));
            }
            NSLog(@"Duration:%.2f",anim.duration);
            NSLog(@"TimingFunction:%@",anim.timingFunction);
        }
    }
}

@end
</code></pre>

<p>下面来说明一下上面的代码，这段代码是CALayer做了一个Catalog处理。其中initialize是一个类的方法，是进程开始时初始化类时调用，一般只有类有加载这个方法就会第一个调用了。hackedAddAnimation:forKey:是要被调换的代码。在类的初始化方法initialize中（代码中的第5行）实现了CALayer的addAnimation:forKey:和hackedAddAnimation:forKey:方法的调换。在hackedAddAnimation:forKey:中首先直接调用了[self hackedAddAnimation:forKey:]，也许你会问：这不死循环递归了么？其实不是，应为method_exchangeImplementations实现的是调换而不是替换，所以代码中调用addAnimation:forKey:运行时就成了调用hackedAddAnimation:forKey:。而代码中调用hackedAddAnimation:forKey:运行时成了调用addAnimation:forKey:。所以这里虽然写的是hackedAddAnimation:forKey:，实际上会调用系统Framework中的addAnimation:forKey:。这样做的目的是保证虽然我们把系统的方法改变了，我们还是调用系统的一次，以保持系统功能运行是正常的。在hackedAddAnimation:forKey:剩下的代码就只是把anim动画对象的各个属性的值打印出来了。</p>

<p>好了，把上面的这段代码粘贴到你的代码文件中。然后简单的写个UIAlertView弹出动画代码。</p>

<pre><code>UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Title" message:@"Message" delegate:nil cancelButtonTitle:@"Close" otherButtonTitles:nil];
[alert show];
</code></pre>

<p>编译并运行上面这段代码，你就会在控制台中看到下面这些日志：</p>

<pre><code>2013-04-10 19:13:11.795 Test[10952:c07] From:[0.01, 0, 0, 0.01, 0, 0]
2013-04-10 19:13:11.796 Test[10952:c07] Duration:0.20
2013-04-10 19:13:11.796 Test[10952:c07] TimingFunction:easeInEaseOut
2013-04-10 19:13:11.999 Test[10952:c07] From:[1.1, 0, 0, 1.1, 0, 0]
2013-04-10 19:13:12.000 Test[10952:c07] Duration:0.10
2013-04-10 19:13:12.000 Test[10952:c07] TimingFunction:easeInEaseOut
2013-04-10 19:13:12.101 Test[10952:c07] From:[0.9, 0, 0, 0.9, 0, 0]
2013-04-10 19:13:12.101 Test[10952:c07] Duration:0.10
2013-04-10 19:13:12.101 Test[10952:c07] TimingFunction:easeInEaseOut
</code></pre>

<p>查看CGAffineTransformMakeScale函数的头文件你会看到：</p>

<pre><code>/* Return a transform which scales by `(sx, sy)':
     t' = [ sx 0 0 sy 0 0 ] */

CG_EXTERN CGAffineTransform CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)
  CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);
</code></pre>

<p>所以根据日志我们会发现这其实是3个关键帧动画，首先scale(缩放比例)从0.01放大到1.1，历时0.2秒；然后从1.1到0.9，历时0.1秒；那么最后就是从0.9到1.0（正常缩放比例），历时0.1秒。哈哈，那我们就简单的写个关键帧动画对象就可以表示UIAlertView的弹出动画效果了。</p>

<pre><code>CAKeyframeAnimation *popAnimation = [CAKeyframeAnimation animationWithKeyPath:@"transform"];
popAnimation.duration = 0.4;
popAnimation.values = @[[NSValue valueWithCATransform3D:CATransform3DMakeScale(0.01f, 0.01f, 1.0f)],
                        [NSValue valueWithCATransform3D:CATransform3DMakeScale(1.1f, 1.1f, 1.0f)],
                        [NSValue valueWithCATransform3D:CATransform3DMakeScale(0.9f, 0.9f, 1.0f)],
                        [NSValue valueWithCATransform3D:CATransform3DIdentity]];
popAnimation.keyTimes = @[@0.0f, @0.5f, @0.75f, @1.0f];
popAnimation.timingFunctions = @[[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
                                 [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut],
                                 [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut]];
[anAlertAnimationView.layer addAnimation:popAnimation forKey:nil];
</code></pre>

<p>你可以把popAnimation加入到你想进行动画的任何View中的layer中这样就实现了UIAlertView一样的弹出动画效果。</p>

<h2>结论</h2>

<ol>
<li>UIAlertView动画其实是由三部分动画组成：缩放比例变化0.01->1.1->0.9->1.0。每次变化的时间函数（控制加速度）都是EaseInEaseOut。</li>
<li>在研究系统中调用函数的参数是我们可以用method_exchangeImplementations来hack到系统调用中去，但不要忘记调用系统本身的方法。否则容易导致App异常。当然，如果你是研究测试不怕crash，那随便。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的模糊效果]]></title>
    <link href="http://blog.xcodev.com/blog/2013/04/01/blur-effect-in-ios/"/>
    <updated>2013-04-01T21:58:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/04/01/blur-effect-in-ios</id>
    <content type="html"><![CDATA[<p>App设计时往往会用到一些模糊效果。iOS目前已提供一些模糊API可以让我们方便是使用。一种是使用Core Image，另一种是使用Accelerate.Framework中的vImage API。</p>

<h2>使用Core Image进行模糊</h2>

<p>Core Image很早在Mac系统中得到应用，后来这个Framework也开始应用到iOS，不过直到iOS6.0才开始支持模糊。这个API调用起来很方便简洁。</p>

<pre><code>- (UIImage *)blurryImage:(UIImage *)image 
           withBlurLevel:(CGFloat)blur {
    CIImage *inputImage = [CIImage imageWithCGImage:image.CGImage];
    CIFilter *filter = [CIFilter filterWithName:@"CIGaussianBlur"
                         keysAndValues:kCIInputImageKey, inputImage,
                                       @"inputRadius", @(blur), 
                                       nil];

    CIImage *outputImage = filter.outputImage;

    CGImageRef outImage = [self.context createCGImage:outputImage 
                                   fromRect:[outputImage extent]];
    return [UIImage imageWithCGImage:outImage];
}
</code></pre>

<!--more-->


<h2>使用vImage API进行模糊</h2>

<p>iOS5.0中新增了vImage API可以使用，它属于Accelerate.Framework，所以如果你要使用它要在工程中加入这个Framework。模糊算法使用的是vImageBoxConvolve_ARGB8888这个函数。</p>

<pre><code>- (UIImage*)bluredImageWithRadius:(CGFloat)blurRadius{
    UIGraphicsBeginImageContextWithOptions(self.size, NO, [self scale]);
    CGContextRef effectInContext = UIGraphicsGetCurrentContext();
    CGContextScaleCTM(effectInContext, 1.0, -1.0);
    CGContextTranslateCTM(effectInContext, 0, -self.size.height);
    CGContextDrawImage(effectInContext, CGRectMake(0, 0, self.size.width, self.size.height), self.CGImage);
    vImage_Buffer effectInBuffer;
    effectInBuffer.data     = CGBitmapContextGetData(effectInContext);
    effectInBuffer.width    = CGBitmapContextGetWidth(effectInContext);
    effectInBuffer.height   = CGBitmapContextGetHeight(effectInContext);
    effectInBuffer.rowBytes = CGBitmapContextGetBytesPerRow(effectInContext);

    UIGraphicsBeginImageContextWithOptions(self.size, NO, [self scale]);
    CGContextRef effectOutContext = UIGraphicsGetCurrentContext();
    vImage_Buffer effectOutBuffer;
    effectOutBuffer.data     = CGBitmapContextGetData(effectOutContext);
    effectOutBuffer.width    = CGBitmapContextGetWidth(effectOutContext);
    effectOutBuffer.height   = CGBitmapContextGetHeight(effectOutContext);
    effectOutBuffer.rowBytes = CGBitmapContextGetBytesPerRow(effectOutContext);

    BOOL hasBlur = blurRadius &gt; __FLT_EPSILON__;

    if (hasBlur) {
        CGFloat inputRadius = blurRadius * [[UIScreen mainScreen] scale];
        NSUInteger radius = floor(inputRadius * 3. * sqrt(2 * M_PI) / 4 + 0.5);
        if (radius % 2 != 1) {
            radius += 1; // force radius to be odd so that the three box-blur methodology works.
        }
        vImageBoxConvolve_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, NULL, 0, 0, radius, radius, 0, kvImageEdgeExtend);
        vImageBoxConvolve_ARGB8888(&amp;effectOutBuffer, &amp;effectInBuffer, NULL, 0, 0, radius, radius, 0, kvImageEdgeExtend);
        vImageBoxConvolve_ARGB8888(&amp;effectInBuffer, &amp;effectOutBuffer, NULL, 0, 0, radius, radius, 0, kvImageEdgeExtend);
    }

    UIImage *returnImage = UIGraphicsGetImageFromCurrentImageContext();

    UIGraphicsEndImageContext();
    UIGraphicsEndImageContext();

    return returnImage;
}
</code></pre>

<p>参考：<a href="http://blog.denivip.ru/index.php/2013/01/blur-effect-in-ios-applications/?lang=en">Blur effect in iOS application</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode字符串调试时显示问题]]></title>
    <link href="http://blog.xcodev.com/blog/2013/01/25/xcode-debug-string-show/"/>
    <updated>2013-01-25T01:52:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/01/25/xcode-debug-string-show</id>
    <content type="html"><![CDATA[<p>今天一位同事调试时发现了一个问题：一个字符串在被replace后，调试时并没有被replace。代码如下：</p>

<pre><code>NSString *s = @"深圳市";
s = [s stringByReplacingOccurrencesOfString:@"市" withString:@""];
NSLog(@"%@",s);
return YES;
</code></pre>

<!--more-->


<p>我在最后设置的一个断点，看看运行后的情况：</p>

<p><img src="http://blog.xcodev.com/images/post/xcode-string-show-breakpoint.png" alt="image" /></p>

<p>可以看出左侧的s中显示并不是“深圳”，而是“深圳市 ”，貌似并没有替换掉。但右侧Log输出却是深圳。那么究竟那个是对的呢？</p>

<p>其实在系统中NSString对象主要有两个属性：一个unichar(2个字节)数组, 另一个是长度。如果仅仅是把字符串末位的一些字去掉的话，unichar数组的内容并没有修改，而仅仅修改了长度属性。</p>

<p>我们在看看控制台左侧的显示格式，就会更明白了。</p>

<p><img src="http://blog.xcodev.com/images/post/xcode-string-show-summary.png" alt="image" /></p>

<p>可以看出实际显示的是unichar*，由于replace后unichar*指针地址并没有改变，变的只是length属性，所以显示也没有变。</p>

<h2>结论</h2>

<p>有时候我们在看字符串的内容时，特别时仅仅进行了尾部替换为空这些操作时，我们不能仅仅看控制台变量的显示，我们要Print Descripton。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS崩溃日志分析]]></title>
    <link href="http://blog.xcodev.com/blog/2012/12/07/ios-crash-log-analycis/"/>
    <updated>2012-12-07T01:44:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2012/12/07/ios-crash-log-analycis</id>
    <content type="html"><![CDATA[<h2>崩溃日志的产生</h2>

<p>iOS中运行App过程中如果发生程序崩溃，会生成一个崩溃日志文件。这个文件会保存的特定系统目录下，扩展名是crash。当手机连接到iTunes时，会将该文件同步到电脑上。</p>

<p>在Mac系统中这些文件会同步到“~/Library/Logs/CrashReporter/MobileDevice”下。</p>

<p>而在Windows系统中会同步到“C:UsersAppDataRoamingApple computerLogsCrashReporter/MobileDevice”（Vista或以上）或“C:Documents and SettingsApplication DataApple computerLogsCrashReporter”（XP）。</p>

<!--more-->


<h2>崩溃日志的上传</h2>

<p>iOS中崩溃日志是可以上传的App Store的服务器，并由开发者查看的。用户可以通过系统设置中的“通用－诊断与用量”来设定是否上传崩溃日志。同时开发者也可以通过捕获异常信号自己定制异常上报。</p>

<h2>崩溃日志的格式</h2>

<p>一般崩溃日志头部有如下字段</p>

<pre><code>Exception Type:  EXC_BAD_ACCESS (SIGSEGV)
Exception Codes: KERN_INVALID_ADDRESS at 0x20000008
Crashed Thread:  0
</code></pre>

<p>其中Exception Type是异常类型，Exception Codes是异常代码。Crashed Thread指示异常的线程编号。上面表示Crash的线程编号是0（主线程的线程编号是0）。</p>

<p>看崩溃日志时一般要分两种情况，一种是内存、CPU的系统错误，如内存访问错误、除零异常等。另外一种是程序通过写代码抛出的异常，即代码中通过throw关键字抛出的异常。程序抛出的异常是可以捕获并处理的，如果没有捕获，就会Crash，并生成崩溃日志。这两种在日志中有一些细微的差别。</p>

<p>一般内存等系统异常Crash线程信息如下：</p>

<pre><code>Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libobjc.A.dylib                 0x3624cf78 objc_msgSend + 16
1   QQYanChu                        0x0000d92a -[QYServerInterface connectionDidFinishLoading:] (QYServerInterface.m:328)
2   Foundation                      0x30d03c22 __65-[NSURLConnectionInternal _withConnectionAndDelegate:onlyActive:]_block_invoke_0 + 10
3   Foundation                      0x30c5b6d2 -[NSURLConnectionInternalConnection invokeForDelegate:] + 22
4   Foundation                      0x30c5b69c -[NSURLConnectionInternal _withConnectionAndDelegate:onlyActive:] + 192
5   Foundation                      0x30c5b5be -[NSURLConnectionInternal _withActiveConnectionAndDelegate:] + 54
6   CFNetwork                       0x338077ee URLConnectionClient::_clientDidFinishLoading(URLConnectionClient::ClientConnectionEventQueue*) + 186
7   CFNetwork                       0x337fc49e URLConnectionClient::ClientConnectionEventQueue::processAllEventsAndConsumePayload(XConnectionEventInfo&lt;XClientEvent, XClientEventParams&gt;*, long) + 418
8   CFNetwork                       0x337fc592 URLConnectionClient::ClientConnectionEventQueue::processAllEventsAndConsumePayload(XConnectionEventInfo&lt;XClientEvent, XClientEventParams&gt;*, long) + 662
9   CFNetwork                       0x337fc19c URLConnectionClient::processEvents() + 100
10  CFNetwork                       0x337fc0d2 MultiplexerSource::perform() + 150
11  CoreFoundation                  0x34dffacc __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 8
12  CoreFoundation                  0x34dff298 __CFRunLoopDoSources0 + 208
13  CoreFoundation                  0x34dfe03e __CFRunLoopRun + 646
14  CoreFoundation                  0x34d8149e CFRunLoopRunSpecific + 294
15  CoreFoundation                  0x34d81366 CFRunLoopRunInMode + 98
16  GraphicsServices                0x3607d432 GSEventRunModal + 130
17  UIKit                           0x31e77e76 UIApplicationMain + 1074
18  QQYanChu                        0x0000feea main (main.m:39)
19  QQYanChu                        0x00007ed4 start + 32
</code></pre>

<p>第一列是编号，表示堆栈中函数调用的嵌套顺序。最上面就是崩溃发生的函数，往下面看就可以看到我们的代码。第二列是堆栈中函数定义的位置，有的是在动态库或Framework中定义的，有的是我们的App定义的，如QQYanChu就是我们的App可执行文件，另外你还可以看到其他的动态库等，一般我们关注自己的QQYanChu的就行了。 如上面的例子就是在-[QYServerInterface connectionDidFinishLoading:] 这个调用中挂的。一般这个信息还会包含代码文件和说对应的行号，如上面红色部分就是说崩溃在QYServerInterface.m的328行。这就可以方便我们快速定位问题。</p>

<p>下面是程序抛出的异常的日志。</p>

<pre><code>Last Exception Backtrace:
0   CoreFoundation                  0x3425929e __exceptionPreprocess + 158
1   libobjc.A.dylib                 0x33a2b97a objc_exception_throw + 26
2   CoreFoundation                  0x3425ce02 -[NSObject(NSObject) doesNotRecognizeSelector:] + 166
3   CoreFoundation                  0x3425b52c ___forwarding___ + 388
4   CoreFoundation                  0x341b2f64 _CF_forwarding_prep_0 + 20
5   QQYanChu                        0x000ef372 -[QYUser staticDataFetcher:fetchedData:] (QYUser.m:168)
6   QQYanChu                        0x001ee9f2 -[QStaticDataFetcher successWithData:] + 94
7   QQYanChu                        0x001efb44 -[QStaticDataFetcher sendDelegateMessageWithLocalData] + 220
8   Foundation                      0x39256a6a __NSFireDelayedPerform + 446
9   CoreFoundation                  0x3422e5da __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 10
10  CoreFoundation                  0x3422e28c __CFRunLoopDoTimer + 268
11  CoreFoundation                  0x3422cefc __CFRunLoopRun + 1228
12  CoreFoundation                  0x3419feb8 CFRunLoopRunSpecific + 352
13  CoreFoundation                  0x3419fd44 CFRunLoopRunInMode + 100
14  GraphicsServices                0x34f082e6 GSEventRunModal + 70
15  UIKit                           0x36de52fc UIApplicationMain + 1116
16  QQYanChu                        0x000fcfc0 main (main.m:39)
17  QQYanChu                        0x000ee4d4 start + 36


Thread 0 name:  Dispatch queue: com.apple.main-thread
Thread 0 Crashed:
0   libsystem_kernel.dylib          0x32f28350 __pthread_kill + 8
1   libsystem_c.dylib               0x3830311e pthread_kill + 54
2   libsystem_c.dylib               0x3833f96e abort + 90
3   libc++abi.dylib                 0x38e35d4a abort_message + 70
4   libc++abi.dylib                 0x38e32ff4 default_terminate() + 20
5   libobjc.A.dylib                 0x33a2ba74 _objc_terminate() + 144
6   libc++abi.dylib                 0x38e33078 safe_handler_caller(void (*)()) + 76
7   libc++abi.dylib                 0x38e33110 std::terminate() + 16
8   libc++abi.dylib                 0x38e34594 __cxa_rethrow + 84
9   libobjc.A.dylib                 0x33a2b9cc objc_exception_rethrow + 8
10  CoreFoundation                  0x3419ff1c CFRunLoopRunSpecific + 452
11  CoreFoundation                  0x3419fd44 CFRunLoopRunInMode + 100
12  GraphicsServices                0x34f082e6 GSEventRunModal + 70
13  UIKit                           0x36de52fc UIApplicationMain + 1116
14  QQYanChu                        0x000fcfc0 main (main.m:39)
15  QQYanChu                        0x000ee4d4 start + 36
</code></pre>

<p>可以看出相比系统异常日志中多出了Last Exception Backtrace字段。上面是线程0崩溃的，而线程0只调用的abort。这是我们要看Last Exception Backtrace这里的堆栈，这个堆栈是抛出异常时的线程当时的堆栈情况，这个信息才是有意义的。在我们程序抛出异常后，系统会执行一系列相关逻辑后调用abort异常结束程序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS6中的Passbook]]></title>
    <link href="http://blog.xcodev.com/blog/2012/11/16/passbook-in-ios6/"/>
    <updated>2012-11-16T13:41:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2012/11/16/passbook-in-ios6</id>
    <content type="html"><![CDATA[<p>在iOS6中新增了一个内置App：Passbook。Passbook可以保存很多卡片、兑换券之类的东西。每一个叫做一个Pass。其实一个Pass就是一个zip压缩包。这个zip包里包含pass相关的各种文件，如Pass配置文件，显示图标，显示背景等。</p>

<h2>Pass的种类</h2>

<p>Pass目前有5种：Boarding pass、Coupon、Event ticket、Generic、Store card。每种种类都有各自的应用场景的展现布局。展现布局是固定的，但你可以自定义一些效果，如图标、背景和相关文本等。</p>

<!--more-->


<h2>Pass的安全性</h2>

<p>Pass包中的每一个文件都经过签名，任何篡改的Pass都无法添加成功的。</p>

<h2>Pass的更新</h2>

<p>Pass可以通过Push进行更新，这需要一系列的服务器接口。需要注意的是Push所用的证书和签名证书是一样的。</p>

<h2>结论</h2>

<p>由于Pass只是一个zip包，客户端需要做的事情就是下载和调用api添加。一些复杂的签名和更新逻辑则需要服务器端完成。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在iOS中让图片旋转时抗锯齿]]></title>
    <link href="http://blog.xcodev.com/blog/2012/10/25/anti-alise-for-image-ios/"/>
    <updated>2012-10-25T11:36:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2012/10/25/anti-alise-for-image-ios</id>
    <content type="html"><![CDATA[<p>在iOS界面开发时，经常会将某一个视图进行旋转，旋转时会发现图片边缘出现了很多锯齿。即使把layer的edgeAntialiasingMask属性设置了依然会有锯齿。如何才能消除锯齿呢？如果你仔细，你会发现那些边缘虚化(透明)的图片在旋转时并不会出现锯齿。那么如果我们把这些图片的边缘透明化，会不会解决这个问题呢？
我取了一个图片，不进行任何处理，然后让它旋转0.1弧度：</p>

<p><img src="http://blog.xcodev.com/images/post/image-without-anti-alise.png" alt="image" /></p>

<!--more-->


<p>可见确实出现了很多锯齿。
我在图片边缘加了一个像素的透明区域，代码如下：</p>

<pre><code>- (UIImage*)antialiasedImageOfSize:(CGSize)size scale:(CGFloat)scale{
    UIGraphicsBeginImageContextWithOptions(size, NO, scale);
    [self drawInRect:CGRectMake(1, 1, size.width-2, size.height-2)];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return image;
}
</code></pre>

<p>结果完全实现了抗锯齿效果：</p>

<p><img src="http://blog.xcodev.com/images/post/image-with-anti-alise.png" alt="image" /></p>

<h2>结论</h2>

<p>Layer的edgeAntialiasingMask属性并不能有效抗锯齿，只需要在图片边缘加入1个像素的透明区域就可以完美实现图片抗锯齿了。</p>

<p>我把这些代码发布在我的开源项目中了，里面有Demo。项目地址是：<a href="https://github.com/shenqiliang/ImageAntialiase">ImageAntialiase</a></p>
]]></content>
  </entry>
  
</feed>
