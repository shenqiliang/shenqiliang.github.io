<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：iOS开发 | Xcode Dev]]></title>
  <link href="http://blog.xcodev.com/blog/categories/ioskai-fa/atom.xml" rel="self"/>
  <link href="http://blog.xcodev.com/"/>
  <updated>2013-10-21T16:16:04+08:00</updated>
  <id>http://blog.xcodev.com/</id>
  <author>
    <name><![CDATA[谌启亮]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C语言在Category中实现属性]]></title>
    <link href="http://blog.xcodev.com/blog/2013/08/14/implement-objc-property-in-category/"/>
    <updated>2013-08-14T10:43:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/08/14/implement-objc-property-in-category</id>
    <content type="html"><![CDATA[<p>做开发时我们常常会需要在已经实现了的类中增加一些方法，这时候我们一般会用Category的方式来做。但是这样做我们也只能扩展一些方法，而有时候我们更多的是想给它增加一个属性。由于类已经是编译好的了，就不能静态的增加成员了，这样我们就需要自己来实现getter和setter方法了，在这些方法中动态的读写属性变量来实现属性。一种比较简单的做法是使用Objective-C运行时的这两个方法：</p>

<pre><code>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
id objc_getAssociatedObject(id object, const void *key);
</code></pre>

<!--more-->


<p>这两个方法可以让一个对象和另一个对象关联，就是说一个对象可以保持对另一个对象的引用，并获取那个对象。有了这些，就能实现属性功能了。
policy可以设置为以下这些值：</p>

<pre><code>enum {
    OBJC_ASSOCIATION_ASSIGN = 0,
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
    OBJC_ASSOCIATION_RETAIN = 01401,
    OBJC_ASSOCIATION_COPY = 01403
};
</code></pre>

<p>这些值跟属性定义中的nonatomic，copy，retain等关键字的功能类似。</p>

<h2>Example</h2>

<p>下面是一个属性自定义getter和setter的例子：</p>

<pre><code>NSString const * kExposeController = @"exposeController";

- (UIViewController *)exposeController {
    return (UIViewController *)objc_getAssociatedObject(self, kExposeController);
}

- (void)setExposeController:(UIViewController *)exposeController {
    objc_setAssociatedObject(self, kExposeController, exposeController, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
</code></pre>

<p>可以看出使用objc_setAssociatedObject和objc_getAssociatedObject函数可以很方便的实现属性的getter和setter。</p>

<h2>一个很方便的宏</h2>

<p>为此，我特意写了一个Synthesize宏，可以提供@synthesize类似的功能。可以支持两种最常用的属性：非原子retain和assign属性（如果需要其他类型的属性可自行修改）。</p>

<pre><code>#import &lt;objc/runtime.h&gt;
#define SYNTHESIZE_CATEGORY_OBJ_PROPERTY(propertyGetter, propertySetter)                                                             
- (id) propertyGetter {                                                                                                             
    return objc_getAssociatedObject(self, @selector( propertyGetter ));                                                             
}                                                                                                                                   
- (void) propertySetter (id)obj{                                                                                                    
    objc_setAssociatedObject(self, @selector( propertyGetter ), obj, OBJC_ASSOCIATION_RETAIN_NONATOMIC);                            
}


#define SYNTHESIZE_CATEGORY_VALUE_PROPERTY(valueType, propertyGetter, propertySetter)                                                
- (valueType) propertyGetter {                                                                                                      
    valueType ret = {0};                                                                                                                  
    [objc_getAssociatedObject(self, @selector( propertyGetter )) getValue:&amp;ret];                                                    
    return ret;                                                                                                                     
}                                                                                                                                   
- (void) propertySetter (valueType)value{                                                                                           
    NSValue *valueObj = [NSValue valueWithBytes:&amp;value objCType:@encode(valueType)];                                                
    objc_setAssociatedObject(self, @selector( propertyGetter ), valueObj, OBJC_ASSOCIATION_RETAIN_NONATOMIC);                       
}
</code></pre>

<p>用这个宏只需要指定相关属性的类型，getter和setter就可以快速的实现一个属性。比如在UIAlert的Category实现一个非原子retain属性userInfo，以及一个assign的类型为CGRect的customArea属性：</p>

<p>UIAlertView+Ex.h</p>

<pre><code>@interface UIAlertView (Ex)
@property(nonatomic, retain) id userInfo;
@property(nonatomic) CGRect customArea;
@end
</code></pre>

<p>UIAlertView+Ex.m</p>

<pre><code>@implementation UIAlertView (Ex)
SYNTHESIZE_CATEGORY_OBJ_PROPERTY(userInfo, setUserInfo:)
SYNTHESIZE_CATEGORY_VALUE_PROPERTY(CGRect, customArea, setCustomArea:)
@end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS5网页视图（UIWebView）中的输入框不能弹出键盘的问题]]></title>
    <link href="http://blog.xcodev.com/blog/2013/07/30/no-keyboard-in-webview-of-ios5/"/>
    <updated>2013-07-30T10:32:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/07/30/no-keyboard-in-webview-of-ios5</id>
    <content type="html"><![CDATA[<p>项目开发时，发现有时候在网页视图中的输入框获得焦点后，却不能弹出键盘。而且全部都是在iOS5的系统中出现了这个问题，iOS6中运行完全是正常的，而且即使是在iOS5中，其他的UITextView和UITextField仍然可以正常地弹出键盘。我仔细了看了一下代码，发现对UIWebView的一些操作和键盘弹出并没有什么关系。我看了一些UIWebView的一些资料，然后发现了这个问题：UIWebView要能弹出键盘，那么它所在的window必须是key window。</p>

<!--more-->


<h2>什么是key window？</h2>

<p>key window就是接收键盘消息的window。键盘消息都会发送到key window上。而这个key window往往是系统自动设置的，但web view获得焦点并没有自动设置（也许是Apple开发偷了个懒），然而我们也可以用一个方法手动设置。</p>

<pre><code>[window makeKeyAndVisiable]
</code></pre>

<h2>一个演示例子</h2>

<p>为了验证这个问题我也写了一段简短的代码：</p>

<pre><code>UIWebView *webView = [[UIWebView alloc] initWithFrame:self.window.bounds];
[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@"http://www.google.com"]]];
[self.window addSubview:webView];

UIWindow *anotherWindow = [UIWindow new];
[anotherWindow makeKeyAndVisible];
</code></pre>

<p>这段代码在iOS5中运行的话，即使输入框获得了焦点也不能弹出键盘。
<img src="/images/post/no-keyboard-in-webview.jpg" alt="image" /></p>

<h2>解决方案</h2>

<p>如果在UIWebView被添加的window上时，将window设置为key window就好了。</p>

<pre><code>[self.window makeKeyAndVisiable]
[self.window addSubview:webView];
</code></pre>

<h2>小结</h2>

<p>UIWebView要能弹出键盘，那么它所在的window必须是key window。如果你的App可能存在多个Window（如弹出自定义的Alert，状态条等），而且这些window有可能被设置为key window，一定要在web view显示时将它所在的window设置为key window。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TableView中嵌套一个ScrollView有时导致ScrollView无法滚动]]></title>
    <link href="http://blog.xcodev.com/blog/2013/07/17/cant-scroll-in-tableview/"/>
    <updated>2013-07-17T15:34:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/07/17/cant-scroll-in-tableview</id>
    <content type="html"><![CDATA[<h2>TableView中嵌套ScrollView导致ScrollView无法滚动</h2>

<p>开发时，经常会在一个TableView中嵌套一个横向滚动ScrollView，当ScrollView进行滑动时，TableView中展示的信息也会需要相应的改变，那么有时就需要重新载入TableView的数据（reloadData）。这时当ScrollView连续滚动多次，经常会出现ScrollView滚动不了。在控制台上同时会出现以下日志信息：</p>

<pre><code>Ignoring call to [UIPanGestureRecognizer setTranslation:inView:] since gesture recognizer is not active.
</code></pre>

<!--more-->


<p>在QQ电影票新版开发过程中就遇到了这个问题。</p>

<p><img src="/images/post/scrollView_in_tableView.jpg" alt="image" /></p>

<p>中间显示电影列表的是一个ScrollView。滑动过程中，如果中间箭头所指向的电影发生变化，整个界面信息就会刷新，调用TableView的reloadData。经过几次连续不间断的滑动电影列表后，就会导致ScrollView卡住，然后控制台就会出现“Ignoring call to [UIPanGestureRecognizer setTranslation:inView:] since gesture recognizer is not active.”的错误日志。</p>

<h2>原因分析</h2>

<p>开始时我以为是我自定义的ScrollView控件有问题，尝试各种屏蔽代码的方法，结果只有屏蔽的delegate的方法才不会出现问题，应该是delegate中的某些调用出现了问题。我仔细的检查了一下delegate方法，发现和TableView有关的一句代码：</p>

<pre><code>[self.tableView reloadData];
</code></pre>

<p>当我把reloadData注释调时，发现滑动起来很流畅，也没有出现这个问题了。可以断定时滑动过程中reloadData导致。结合错误日志，所以应该是滑动时同时reloadData，导致ScrollView的滑动手势失效。</p>

<h2>解决办法</h2>

<p>因为是在ScrollView的delegate消息中去调tableView的reloadData，可能在ScrollView的delegate消息处理完成之后，系统还会做一些其他的处理，这是你突然reloadData会导致ScrollView移出superView，然后导致滑动手势失效，所以我尝试异步调用一下TableView的reloadData：</p>

<pre><code>dispatch_async(dispatch_get_main_queue(), ^{
     [self.tableView reloadData];
});
</code></pre>

<p>结果果然没有问题了。其实我觉得更好的做法是直接将delegate消息调用写成异步调用会更好一些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 5中使用UIAppearance来自定义应用的外观]]></title>
    <link href="http://blog.xcodev.com/blog/2013/06/12/custom-ui-using-uiappearance/"/>
    <updated>2013-06-12T16:31:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/06/12/custom-ui-using-uiappearance</id>
    <content type="html"><![CDATA[<p>做App时，我们经常需要自定义一些界面展现，来适合我们App的内容，或来使App看起来更漂亮，有时我们不得不写大量的自定义控件来达到这个目的。iOS 5新增了UIAppearance协议，使得自定义风格简单方便了很多，通过UIAppearance协议，我们快速的修改系统内置的控件的外观，也可以自己定义一些可自定义外观的控件。</p>

<!--more-->


<h2>系统框架控件的一些自定义方法</h2>

<h4>自定义导航条背景</h4>

<pre><code>[[UINavigationBar appearance] setBackgroundImage:[UIImage imageNamed:@"background"] forBarMetrics:UIBarMetricsDefault];
</code></pre>

<h4>自定义导航标题文字属性</h4>

<pre><code>[[UINavigationBar appearance] setTitleTextAttributes:@{UITextAttributeTextColor:[UIColor darkGrayColor],UITextAttributeTextShadowColor:[UIColor clearColor]}];
</code></pre>

<p>可自定义标题字体，颜色，阴影。</p>

<h4>自定义导航条返回和左右按钮按钮背景</h4>

<pre><code>[[UIBarButtonItem appearanceWhenContainedIn:[UINavigationBar class], nil] setBackButtonBackgroundImage:[UIImage imageNamed:@"back_button_background"] forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];
[[UIBarButtonItem appearanceWhenContainedIn:[UINavigationBar class], nil] setBackgroundImage:[UIImage imageNamed:@"button_background"] forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];
</code></pre>

<h4>自定义底部Tab条的背景</h4>

<pre><code>[[UITabBar appearance] setBackgroundImage:[UIImage imageNamed:@"background"]];
</code></pre>

<h4>自定义底部条标题文字属性</h4>

<pre><code>[[UITabBarItem appearance] setTitleTextAttributes:@{UITextAttributeTextColor:[UIColor grayColor]} forState:UIControlStateNormal];
[[UITabBarItem appearance] setTitleTextAttributes:@{UITextAttributeTextColor:[UIColor orangeColor]} forState:UIControlStateSelected];
</code></pre>

<p>这里列举的都是一些最常用的自定义方法，只要是头文件中有“UI_APPEARANCE_SELECTOR”标记的方法都是可以用UIAppearance协议对象去调的。注意这些自定义方法都要在相应的对象显示之前调用，可以放到App启动后立刻配置，以后只要这个对象显示之前，就会设置相应的属性。</p>

<h2>自己创建一个可自定义外观的控件</h2>

<p>对于我们自己定义的控件，也可以支持UIAppearance协议，这样我们的控件也能支持自定义了。你只需要写一个设置外观的settor，然后在settor方法后面加上“UI_APPEARANCE_SELECTOR”标记就可以，其他什么都不需要做。比如一个可以自定义选择状态背景颜色的TableViewCell。</p>

<pre><code>@interface CustomCell : UITableViewCell
- (void)setSelectedBackgroundColor:(UIColor*)color UI_APPEARANCE_SELECTOR;
@end

@implementation CustomCell
- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
    self = [super initWithStyle:style reuseIdentifier:reuseIdentifier];
    if (self) {
        self.selectedBackgroundView = [UIView new];
        self.selectedBackgroundView.backgroundColor = [UIColor lightGrayColor];
    }
    return self;
}
- (void)setSelectedBackgroundColor:(UIColor*)color{
    self.selectedBackgroundView.backgroundColor = color;
}
@end
</code></pre>

<p>注意，官方文档中强调Appearance的setter定义格式应为：</p>

<pre><code>- (void)setProperty:(PropertyType)property forAxis1:(IntegerType)axis1 axis2:(IntegerType)axis2 axisN:(IntegerType)axisN;
- (PropertyType)propertyForAxis1:(IntegerType)axis1 axis2:(IntegerType)axis2 axisN:(IntegerType)axisN;
</code></pre>

<h2>UIAppearance实现原理</h2>

<p>在通过UIAppearance调用“UI_APPEARANCE_SELECTOR”标记的方法来配置外观时，UIAppearance实际上没有进行任何实际调用，而是把这个调用保存起来（在Objc中可以用NSInvocation对象来保存一个调用）。当实际的对象显示之前（添加到窗口上，drawRect:之前），就会对这个对象调用之前保存的调用。当这个setter调用后，你的界面风格自定义就完成了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C中方法签名(Method Signature)机制]]></title>
    <link href="http://blog.xcodev.com/blog/2013/05/30/method-signature-in-objc/"/>
    <updated>2013-05-30T15:23:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/05/30/method-signature-in-objc</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在ObjC语言中，我们会自定义各种各样的类，在类定义中，我们又会定义各种方法，当方法达到一定的数量，有时会不可避免的出现一些同名的方法。而同名的方法有时会导致运行时出现很奇怪的问题。比如传递参数不一致时，出现运行时错误。这些都和ObjC中的方法签名（Method Signature）相关。</p>

<!--more-->


<h2>什么是方法签名</h2>

<p>方法签名是ObjC中对一个方法的参数类型和返回值类型的一条记录。每个方法都对应一个方法签名。</p>

<h2>一些基本概念</h2>

<p>有几个名词在深入理解方法签名机制之前必须区分清楚：
部分可参考我之前的一篇博文：
<a href="/blog/2012/03/22/difference-between-message-and-method/">Objective-C中消息（Message）和方法（Method）的区别</a></p>

<h3>消息</h3>

<p>消息由消息的名字和参数组成，可以有返回值，用于发送给某个对象。大部分我们写的代码都是向一个对象发送消息。比如：</p>

<pre><code>[receiver message];
</code></pre>

<h3>方法</h3>

<p>方法对应一段可执行代码，是implementation的一部分。当我们向某个对象发送消息时，系统会分析我们所发送的消息，动态地调用响应的方法。对应ObjC中的IMP类型。</p>

<h3>Selector</h3>

<p>ObjC中有个SEL类型，这个类型就是Selector的类型。我们可以用@selector操作符来获取一个Selector。Selector可理解为方法的名字，但这并不包含参数和返回值，仅仅是名字。你还需注意，Selector不和任何类关联，你不能说某个Selector属于一个类，它仅仅是名字。</p>

<h2>NSMethodSignature类</h2>

<p>ObjC中有一个NSMethodSignature类，这个类很好的帮助我们来分析一下ObjC中的方法签名机制，这个类中定义了以下几个方法</p>

<pre><code>- (NSUInteger)numberOfArguments;//参数的数量
- (const char *)getArgumentTypeAtIndex:(NSUInteger)idx;//第idx个参数的类型
- (const char *)methodReturnType;//返回值类型
- (NSUInteger)methodReturnLength;//返回值长度，单位字节
</code></pre>

<p>从这些定义中我们可以看出，方法签名中会包含方法的参数个数，每个参数的类型，返回值类型，以及返回值占用的空间大小。
NSObject基类中提供了获取这个对象的方法</p>

<pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
</code></pre>

<p>所以，只要知道一个对象，和一个SEL（selector），那么就可以动态的获取这个方法签名了。</p>

<h2>参数类型签名不同导致的一个奇怪现象</h2>

<p>下面先举个例子，来看看参数类型签名不同导致的一个奇怪现象。
首先我们定义两个类，两个类是继承关系，但定义了同名的方法，但方法的参数类型不同。（所以它们的方法签名是不同的。）</p>

<pre><code>//基类
@interface ParamBase : NSObject
- (void)doSomeThing:(int)i;
@end

@implementation ParamBase
- (void)doSomeThing:(int)i{
    NSLog(@"Base doSomeThing called with int: %d",i);
}
@end

//子类
@interface ParamSub : ParamBase
- (void)doSomeThing:(double)d;
@end

@implementation ParamSub
- (void)doSomeThing:(double)d{
    NSLog(@"Sub doSomeThing called with double: %f",d);
}
@end
</code></pre>

<p>然后，我们创建个子类对象，然后分别在不同情况下执行doSomeThing，我们都传递相同的参数。</p>

<pre><code>ParamBase *a = [ParamSub new];
[a doSomeThing:1.0];
[(ParamSub*)a doSomeThing:1.0];
</code></pre>

<p>然后运行，你会得到如下结果。</p>

<pre><code>2013-05-30 14:25:03.242 MethodSignTest[2144:c07] Sub doSomeThing called with double: 0.000000
2013-05-30 14:25:03.244 MethodSignTest[2144:c07] Sub doSomeThing called with double: 1.000000
</code></pre>

<p>向一个对象发送了相同的消息，并且参数相同，为什么两次得到的结果不同。明明发送了1，为什么确变成0了。这其实是方法签名在编译阶段时捣鬼。当编译第二行代码时，编译器发现ParamBase对象的doSomeThing方法签名中的第一个参数是int类型，虽然代码了写的是1.0，但编译后就转换整数1了。运行时在子类的doSomeThing把整数1强制以double类型打印出来就是0了。而第3行代码就没有问题。应为编译器已经知道a已强制为ParamSub类型，而ParamSub对象doSomeThing方法签名中的第一个参数是double类型，而不是int类型，所以就没问题了。</p>

<h2>在ARC（自动引用计数机制）下返回值类型签名不同导致Crash</h2>

<p>我们再定义两个类，两个类还是继承关系，定义了同名的方法，但方法的返回值类型不同。（所以它们的方法签名也是不同的。）</p>

<pre><code>//基类
@interface ReturnBase : NSObject
- (id)getSomeThing;
@end

@implementation ReturnBase
- (id)getSomeThing{
    NSLog(@"Return Base called");
    return [NSArray new];
}
@end

//子类
@interface ReturnSub : ReturnBase
- (void)getSomeThing;
@end

@implementation ReturnSub
- (void)getSomeThing{
    NSLog(@"nothing");
}
@end
</code></pre>

<p>然后我们执行下面这段代码：</p>

<pre><code>ReturnBase *b = [ReturnSub new];
[(ReturnSub*)b getSomeThing];
[b getSomeThing];
</code></pre>

<p>结果程序在第3行Crash了，Crash类型一般是内存访问（BAD ACCESS）错误。第2行和第3行在ObjC动态绑定的机制下完全是相同的代码啊，为什么第2行没Crash，到第3行就Crash了呢？这是由于ARC和方法签名机制共同作用的结果，ARC下系统会对消息的返回值自动做一些retain或release等操作，而b在运行时ReturnSub类型，getSomeThing是不返回任何对象的。第二行时编译器知道b是ReturnSub类型，所以不会处理返回值了，而在第3行时，编译器认为b是ReturnBase类型，而根据ReturnBase类的方法getSomeThing的签名，是有返回值的，所以第3行编译后会自动对getSomeThing的返回值加一些retain/release等操作，而运行时却是没有返回值的（void类型），那么返回值就是不确定的，对这个不确定的值进行retain/release操作，一般就会导致内存访问（BAD ACCESS）错误。
也许你会想，我如果把b设为id类型，会怎样。</p>

<pre><code>id b = [ReturnSub new];
[(ReturnSub*)b getSomeThing];
[b getSomeThing];
</code></pre>

<p>结果是编译不通过，名字为getSomeThing的方法的签名不一致，编译器就不知道有没有返回值了。</p>

<h2>结论</h2>

<p>方法签名在编译时对方法的参数进行一定的转换。
ARC下会根据方法签名中的返回值进行retain/release等操作
最好不要写方法名字相同，当方法签名不同的方法，以免出现怪异现象。
有时我们改变了一个基类的参数类型或返回值类型，不要忘记了在子类中进行相应的修改。</p>
]]></content>
  </entry>
  
</feed>
