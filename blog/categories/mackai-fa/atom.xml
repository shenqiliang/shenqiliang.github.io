<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：Mac开发 | Xcode Dev]]></title>
  <link href="http://blog.xcodev.com/blog/categories/mackai-fa/atom.xml" rel="self"/>
  <link href="http://blog.xcodev.com/"/>
  <updated>2013-10-30T15:53:51+08:00</updated>
  <id>http://blog.xcodev.com/</id>
  <author>
    <name><![CDATA[谌启亮]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[并发编程之Operation Queue]]></title>
    <link href="http://blog.xcodev.com/blog/2013/10/28/operation-queue-intro/"/>
    <updated>2013-10-28T11:26:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/10/28/operation-queue-intro</id>
    <content type="html"><![CDATA[<p>随着移动设备的更新换代，移动设备的性能也不断提高，现在流行的CPU已经进入双核、甚至四核时代。如何充分发挥这些CPU的性能，会变得越来越重要。在iOS中如果想要充分利用多核心CPU的优势，就要采用并发编程，提高CPU的利用率。iOS中并发编程中主要有2种方式Operation Queue和GCD（Grand Central Dispatch）。下面就来先来说一下Operation Queue。</p>

<!--more-->


<h2>异步调用和并发</h2>

<p>在深入之前，首先说说异步调用和并发。这两个概念在并发编程中很容易弄混淆。异步调用是指调用时无需等待结果返回的调用，异步调用往往会触发后台线程处理，比如NSURLConnection的异步网络回调。并发是指多个任务（线程）同时执行。在异步调用的实现中往往采用并发机制，然而并不是所有异步都是并发机制，也有可能是其他机制，比如一些依靠中断进行的操作。</p>

<h2>为什么Operation Queue</h2>

<p>Operation Queue提供一个面向对象的并发编程接口，支持并发数，线程优先级，任务优先级，任务依赖关系等多种配置，可以方便满足各种复杂的多任务处理场景。</p>

<ul>
<li>面向对象接口</li>
<li>支持并发数配置</li>
<li>任务优先级调度</li>
<li>任务依赖关系</li>
<li>线程优先级配置</li>
</ul>


<h2>NSOperation简介</h2>

<p>iOS并发编程中，把每个并发任务定义为一个Operation，对应的类名是NSOperation。NSOperation是一个抽象类，无法直接使用，它只定义了Operation的一些基本方法。我们需要创建一个继承于它的子类或者使用系统预定义的子类。目前系统预定义了两个子类：NSInvocationOperation和NSBlockOperation。</p>

<h3>NSInvocationOperation</h3>

<p>NSInvoationOperation是一个基于对象和selector的Operation，使用这个你只需要指定对象以及任务的selector，如果必要，你还可以设定传递的对象参数。</p>

<pre><code>NSInvocationOperation *invacationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(doSomethingWithObj:) object:obj];
</code></pre>

<p>同时当这个Operation完成后，你还可以获取Operation中Invation执行后返回的结果对象。</p>

<pre><code>id result = [invacationOperation result];
</code></pre>

<h3>NSBlockOperation</h3>

<p>在一个Block中执行一个任务，这时我们就需要用到NSBlockOperation。可以通过<code>blockOperationWithBlock:</code>方法来方便地创建一个NSBlockOperation：</p>

<pre><code>NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^{
    //Do something here.
}];
</code></pre>

<h3>运行一个Operation</h3>

<p>调用Operation的<code>start</code>方法就可以直接运行一个Operation。</p>

<pre><code>[operation start];
</code></pre>

<p><code>start</code>方法用来启动一个Operation任务。同时，Operation提供一个<code>main</code>方法，你的所有任务都应该在main中进行处理。默认的<code>start</code>方法中会先做出一些异常判断然后直接调用<code>main</code>方法。如果需要自定义一个NSOperation必须重载<code>main</code>方法来执行你所想要执行的任务。</p>

<pre><code>@implementation CustomOperation

-(void)main {
   @try {
      // Do some work.
   }
   @catch(...) {
      // Exception handle.
   }
}
@end
</code></pre>

<h3>取消一个Operation</h3>

<p>要取消一个Operation，要向Operation对象发送cancel消息：</p>

<pre><code>[operation cancel];
</code></pre>

<p>当向一个Operation对象发送cancel消息后，并不保证这个Operation对象一定能立刻取消，这取决于你的<code>main</code>中对<code>cancel</code>的处理。如果你在<code>main</code>方法中没有对<code>cancel</code>进行任何处理的话，发送<code>cancel</code>消息是没有任何效果的。为了让Operation响应<code>cancel</code>消息，那么你就要在<code>main</code>方法中一些适当的地方手动的判断<code>isCancelled</code>属性，如果返回<code>YES</code>的话，应释放相关资源并立刻停止继续执行。</p>

<h3>创建可并发的Operation</h3>

<p>由于默认情况下Operation的<code>start</code>方法中直接调用了<code>main</code>方法，而<code>main</code>方法中会有比较耗时的处理任务。如果我们在一段代码连续<code>start</code>了多个Operation，这些Operation都是阻塞地依次执行完，因为第二个Operation必须等到第一个Operation执行完<code>start</code>内的<code>main</code>并返回。Operation默认都是不可并发的（使用了Operation Queue情况下除外，Operation Queue会独自管理自己的线程），因为默认情况下Operation并不额外创建线程。我们可以通过Operation的<code>isConcurrent</code>方法来判断Operation是否是可并发的。如果要让Operation可并发，我们需要让<code>main</code>在独立的线程中执行，并将<code>isConcurrent</code>返回YES。</p>

<pre><code>@implementation MyOperation{
    BOOL        executing;
    BOOL        finished;
}


- (BOOL)isConcurrent {
    return YES;
}

- (void)start {
   if ([self isCancelled])
   {
      [self willChangeValueForKey:@"isFinished"];
      finished = YES;
      [self didChangeValueForKey:@"isFinished"];
      return;
   }

   [self willChangeValueForKey:@"isExecuting"];
   [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];
   executing = YES;
   [self didChangeValueForKey:@"isExecuting"];
}

- (void)main {
   @try {
        // Do some work.

        [self willChangeValueForKey:@"isFinished"];
        [self willChangeValueForKey:@"isExecuting"];
        executing = NO;
        finished = YES;
        [self didChangeValueForKey:@"isExecuting"];
        [self didChangeValueForKey:@"isFinished"];

   }
   @catch(...) {
      // Exception handle.
   }
}

@end
</code></pre>

<p>当你自定义了<code>start</code>或<code>main</code>方法时，一定要手动的调用一些KVO通知方法，以便让对象的KVO机制可以正常运作。</p>

<h3>设置Operation的completionBlock</h3>

<p>每个Operation都可以设置一个<code>completionBlock</code>，在Operation执行完成时自动执行这个Block。我们可以在此进行一些完成的处理。<code>completionBlock</code>实现原理是对Operation的<code>isFinnshed</code>字段进行KVO（Key-Value Observing），当监听到<code>isFinnished</code>变成YES时，就执行<code>completionBlock</code>。</p>

<pre><code>operation.completionBlock = ^{
    NSLog(@"finished");
};
</code></pre>

<h3>设置Operation的线程优先级</h3>

<p>我们可以为Operation设置一个线程优先级，即<code>threadPriority</code>。那么执行<code>main</code>的时候，线程优先级就会调整到所设置的线程优先级。这个默认值是0.5，我们可以在Operation执行前修改它。</p>

<pre><code>operation.threadPriority = 0.1;
</code></pre>

<p>注意：如果你重载的<code>start</code>方法，那么你需要自己来配置<code>main</code>执行时的线程优先级和<code>threadPriority</code>字段保持一致。</p>

<h3>Operation状态变化</h3>

<p>我们可以通过KVO机制来监听Operation的一下状态改变，比如一个Operation的执行状态或完成状态。这些状态的keypath包括以下几个：</p>

<ul>
<li>isCancelled</li>
<li>isConcurrent</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isReady</li>
<li>dependencies</li>
<li>queuePriority</li>
<li>completionBlock</li>
</ul>


<h2>NSOperationQueue</h2>

<p>NSOperationQueue是一个Operation执行队列，你可以将任何你想要执行的Operation添加到Operation Queue中，以在队列中执行。同时Operation和Operation Queue提供了很多可配置选项。Operation Queue的实现中，创建了一个或多个可管理的线程，为队列中的Operation提供可高度自定的执行环境。</p>

<h3>Operation的依赖关系</h3>

<p>有时候我们对任务的执行顺序有要求，一个任务必须在另一个任务执行之前完成，这就需要用到Operation的依赖（Dependency）属性。我们可以为每个Operation设定一些依赖的另外一些Operation，那么如果依赖的Operation没有全部执行完毕，这个Operation就不会被执行。</p>

<pre><code>[operation addDependency:anotherOperation];
[operation removeDependency:anotherOperation];
</code></pre>

<p>如果将这些Operation和它所依赖的Operation加如队列中，那么Operation只有在它依赖的Operation都执行完毕后才可以被执行。这样我们就可以方便的控制Operation执行顺序。</p>

<h3>Operation在队列中执行的优先级</h3>

<p>Operation在队列中默认是按FIFO（First In First Out）顺序执行的。同时我们可以为单个的Operation设置一个执行的优先级，打乱这个顺序。当Queue有空闲资源执行新的Operation时，会优先执行当前队列中优先级最高的待执行Operation。</p>

<h3>最大并发Operation数目</h3>

<p>在一个Operation Queue中是可以同时执行多个Operation的，Operation Queue会动态的创建多个线程来完成相应Operation。具体的线程数是由Operation Queue来优化配置的，这一般取决与系统CPU的性能，比如CPU的核心数，和CPU的负载。但我们还是可以设置一个最大并发数的，那么Operation Queue就不会创建超过最大并发数量的线程。</p>

<pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];
queue.maxConcurrentOperationCount = 1;
</code></pre>

<p>如果我们将<code>maxConcurrentOperationCount</code>设置为<code>1</code>，那么在队列中每次只能执行一个任务。这就是一个串行的执行队列了。</p>

<h3>Simple Code</h3>

<p>下面我写了一个简单的Simple Code来说明一下Operation和Operation Queue。</p>

<pre><code>NSBlockOperation *operation5s = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"operation5s begin");
    sleep(5);
    NSLog(@"operation5s end");
}];
operation5s.queuePriority = NSOperationQueuePriorityHigh;
NSBlockOperation *operation1s = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"operation1s begin");
    sleep(1);
    NSLog(@"operation1s end");
}];
NSBlockOperation *operation2s = [NSBlockOperation blockOperationWithBlock:^{
    NSLog(@"operation2s begin");
    sleep(2);
    NSLog(@"operation2s end");
}];

operation1s.completionBlock = ^{
    NSLog(@"operation1s finished in completionBlock");
};

NSOperationQueue *queue = [[NSOperationQueue alloc] init];
queue.maxConcurrentOperationCount = 1;
[queue addOperation:operation1s];
[queue addOperation:operation2s];
[queue addOperation:operation5s];
[queue waitUntilAllOperationsAreFinished];
</code></pre>

<p>运行这段代码，我得到了一下输出结果：</p>

<pre><code>operation1s begin
operation1s end
operation5s begin
operation1s finished in completionBlock
operation5s end
operation2s begin
operation2s end
</code></pre>

<p>为了更好的展示队列优先级效果，我把queue的<code>maxConcurrentOperationCount</code>设置为<code>1</code>，以便任务一个一个的执行。从上面日志可以看出，第一个operation1s执行完毕后，会执行operation5s，而不是operation2s，因为operation5s的<code>queuePriority</code>是<code>NSOperationQueuePriorityHigh</code>。而第一个线程总是会第一个执行。在看看2-4行，我们可以看出operation1s的<code>completionBlock</code>比operation5s晚开始执行，说明它不在operation1s的线程中执行的。正如前面所说，<code>completionBlock</code>是通过KVO监听执行，一般会运行在主线程。</p>

<h2>注意事项</h2>

<ul>
<li>当一个Operation被加入Queue中后，请不要对这个Operation再进行任何修改。因为一旦加入Queue，它随时就有可能会被执行，对它的任何修改都有可能导致它的运行状态不可控制。</li>
<li><code>threadPriority</code>仅仅影响了<code>main</code>执行时的线程优先级，其他的方法包括<code>completionBlock</code>都是以默认的优先级来执行的。如果自定义的话，也要注意在<code>main</code>执行前设置好<code>threadPriority</code>，执行完毕后要还原默认线程优先级。</li>
<li>经测试，Operation的<code>threadPriority</code>字段只有在Operation单独执行时有效，在Operation Queue中是无效的。</li>
<li>第一个加入到Operation Queue中的Operation，无论它的优先级有多么低，总是会第一个执行。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[64位与Tagged Pointer]]></title>
    <link href="http://blog.xcodev.com/blog/2013/10/21/tagged-pointer-and-64-bit/"/>
    <updated>2013-10-21T16:09:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/10/21/tagged-pointer-and-64-bit</id>
    <content type="html"><![CDATA[<p>在Mac OS X 10.6（Snow Leopard）中开始支持64位，如今最新版本iPhone 5s也开始采用了Arm64架构。在64位化的过程中，其中一个比较关键的改进就是，Mac OS 10.7（Lion）和iOS 7的64位环境先后引入了Tagged Pointer。下面就简单地来介绍一下Tagged Pointer，在介绍Tagged Pointer之前有必要介绍一下指针地址对齐概念和64位环境的一些变化。</p>

<!--more-->


<h2>指针地址对齐</h2>

<p>在32位环境下，如果要读取一个32位整数，如果这个32位整数在内存地址为0x00000002-0x00000006（仅作举例，这个地址一般是被系统保留的）的内存上，读取这个整数会消耗2个CPU周期，而如果这个数在0x00000004-0x00000008的内存上只需要一个CPU周期。为了加快内存的CPU访问，程序都使用了指针地址对齐概念。指针地址对齐就是指在分配堆中的内存时往往采用偶数倍或以2为指数倍的内存地址作为地址边界。几乎所有系统架构，包括Mac OS和iOS，都使用了地址对齐概念。</p>

<pre><code>void *a = malloc(1);
void *b = malloc(3);
NSLog(@"a: %p",a);
NSLog(@"b: %p",b);
</code></pre>

<p>运行这段代码后，我得到了如下结果：</p>

<pre><code>a: 0x8c11e20
b: 0x8c11e30
</code></pre>

<p>可以看到，a和b指针的最后4位都是0，虽然a只占用1个字节，但是a和b的地址却相差16个字节。因为iOS中是以16个字节为内存分配边界的，或者说iOS的指针地址对齐是以16个字节为对齐边界的。进一步说，iOS中分配的内存地址最后4位永远都是0。</p>

<h2>64位地址</h2>

<p>在不久前发布iPhone5s中采用了Arm64的CPU，同时也支持了64位的App。64位App中指针大小也扩大到64位，就是理论上可以支持最大2<sup>64</sup>字节（达千万T字节）的内存地址空间。而对于大多数应用来说，这么大的地址空间完全是浪费的。也就是说64位环境下，内存地址的前面很多位一般都是0。</p>

<h2>Tagged Pointer</h2>

<p>由于指针地址对齐概念和64位超大地址的出现，指针地址仅仅作为内存的地址是比较浪费的，我们可以在指针地址中保存或附加更多的信息。这就引入了Tagged Pointer概念。Tagged Pointer是指那些指针中包含特殊属性或信息的指针。其中指针对齐概念可以让我们来标识一个指针是否是Tagged Pointer以及相关类型，64位的地址指针又为我们提供保存额外信息的足够空间。如今，iOS 7的64位环境和Mac OS 10.7（Lion）中开始引入了Tagged Pointer。</p>

<h2>NSNumber的优化</h2>

<p>Tagged Pointer一个比较典型的应用就是NSNumber，在64位环境下，对于一般的数字，NSNumber不用再分配内存了。我们看看NSNumber是如何运用Tagged Pointer的：</p>

<pre><code>NSNumber *number3 = @3;
NSNumber *number4 = @4;
NSNumber *number9 = @9;
NSLog(@"number3 pointer is %p", number3);
NSLog(@"number4 pointer is %p", number4);
NSLog(@"number9 pointer is %p", number9);
</code></pre>

<p>在64位模拟器中运行后，我得到了如下结果：</p>

<pre><code>number3 pointer is 0xb000000000000032
number4 pointer is 0xb000000000000042
number9 pointer is 0xb000000000000092
</code></pre>

<p>可以看出<code>number3</code>、<code>number4</code>和<code>number9</code>的值前4位都是0xb，后4位都是0x2（指针的Tag），中间就是实际的取值，因此，这些NSNumber已经不需要再分配内存（指堆中内存）了，直接可以把实际的值保存到指针中，而无需再去访问堆中的数据。这无疑提高的内存访问速度和整体运算速度。</p>

<p>也就是说Tagged Pointer本身就可以表示一个NSNumber了，在64位环境下运行这段代码：</p>

<pre><code>NSLog(@"0xb000000000000052's class is %@",[(NSNumber*)0xb000000000000052 class]);
</code></pre>

<p>会输出下面结果：</p>

<pre><code>0xb000000000000052's class is __NSCFNumber
</code></pre>

<p>那么如果一个数超过了Tagged Pointer所能表示的范围，系统会怎么处理？看看这段代码：</p>

<pre><code>NSNumber *numberBig = @(0x1234567890ABCDEF);
NSLog(@"numberBig pointer is %p", numberBig);
</code></pre>

<p>在64位模拟器中运行后，我得到了如下结果：</p>

<pre><code>numberBig pointer is 0x1094026a0
</code></pre>

<p>可以看出<code>numberBig</code>指针最后4位都是0，应该是分配在堆中的对象。因此，如果NSNumber超出了Tagged Pointer所能表示的范围，系统会自动采用分配成对象，可以根据指针的最后4位是否为0来区分。</p>

<h2>isa指针优化</h2>

<p>查看NSObject类的头文件，你会发现这段定义：</p>

<pre><code>@interface NSObject &lt;NSObject&gt; {
    Class isa;
}
</code></pre>

<p>所有类都继承自NSObject，因此每个对象都有一个isa<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>指针指向它所属的类。在《<a href="http://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html">ARM64 and You</a>》文章中指出：</p>

<p>在32位环境下，对象的引用计数都保存在一个外部的表中，而对引用计数的增减操作都要先锁定这个表，操作完成后才解锁。这个效率是非常慢的。</p>

<p>而在64位环境下，isa也是64位，实际作为指针部分只用到的其中33位，剩余的部分会运用到Tagged Pointer的概念，其中19位将保存对象的引用计数，这样对引用计数的操作只需要原子的修改这个指针即可，如果引用计数超出19位，才会将引用计数保存到外部表，而这种情况往往是很少的，因此效率将会大大提高。</p>

<h2>参考文献</h2>

<ul>
<li>Objective-C对象模型及应用： <a href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/">http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/</a></li>
<li>ARM64 and You：<a href="http://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html">http://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html</a></li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>isa是“is a”，比如“Apple is a company”，表示一种从属关系。<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C语言在Category中实现属性]]></title>
    <link href="http://blog.xcodev.com/blog/2013/08/14/implement-objc-property-in-category/"/>
    <updated>2013-08-14T10:43:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/08/14/implement-objc-property-in-category</id>
    <content type="html"><![CDATA[<p>做开发时我们常常会需要在已经实现了的类中增加一些方法，这时候我们一般会用Category的方式来做。但是这样做我们也只能扩展一些方法，而有时候我们更多的是想给它增加一个属性。由于类已经是编译好的了，就不能静态的增加成员了，这样我们就需要自己来实现getter和setter方法了，在这些方法中动态的读写属性变量来实现属性。一种比较简单的做法是使用Objective-C运行时的这两个方法：</p>

<pre><code>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);
id objc_getAssociatedObject(id object, const void *key);
</code></pre>

<!--more-->


<p>这两个方法可以让一个对象和另一个对象关联，就是说一个对象可以保持对另一个对象的引用，并获取那个对象。有了这些，就能实现属性功能了。
policy可以设置为以下这些值：</p>

<pre><code>enum {
    OBJC_ASSOCIATION_ASSIGN = 0,
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1,
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,
    OBJC_ASSOCIATION_RETAIN = 01401,
    OBJC_ASSOCIATION_COPY = 01403
};
</code></pre>

<p>这些值跟属性定义中的nonatomic，copy，retain等关键字的功能类似。</p>

<h2>Example</h2>

<p>下面是一个属性自定义getter和setter的例子：</p>

<pre><code>NSString const * kExposeController = @"exposeController";

- (UIViewController *)exposeController {
    return (UIViewController *)objc_getAssociatedObject(self, kExposeController);
}

- (void)setExposeController:(UIViewController *)exposeController {
    objc_setAssociatedObject(self, kExposeController, exposeController, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
</code></pre>

<p>可以看出使用objc_setAssociatedObject和objc_getAssociatedObject函数可以很方便的实现属性的getter和setter。</p>

<h2>一个很方便的宏</h2>

<p>为此，我特意写了一个Synthesize宏，可以提供@synthesize类似的功能。可以支持两种最常用的属性：非原子retain和assign属性（如果需要其他类型的属性可自行修改）。</p>

<pre><code>#import &lt;objc/runtime.h&gt;
#define SYNTHESIZE_CATEGORY_OBJ_PROPERTY(propertyGetter, propertySetter)                                                             
- (id) propertyGetter {                                                                                                             
    return objc_getAssociatedObject(self, @selector( propertyGetter ));                                                             
}                                                                                                                                   
- (void) propertySetter (id)obj{                                                                                                    
    objc_setAssociatedObject(self, @selector( propertyGetter ), obj, OBJC_ASSOCIATION_RETAIN_NONATOMIC);                            
}


#define SYNTHESIZE_CATEGORY_VALUE_PROPERTY(valueType, propertyGetter, propertySetter)                                                
- (valueType) propertyGetter {                                                                                                      
    valueType ret = {0};                                                                                                                  
    [objc_getAssociatedObject(self, @selector( propertyGetter )) getValue:&amp;ret];                                                    
    return ret;                                                                                                                     
}                                                                                                                                   
- (void) propertySetter (valueType)value{                                                                                           
    NSValue *valueObj = [NSValue valueWithBytes:&amp;value objCType:@encode(valueType)];                                                
    objc_setAssociatedObject(self, @selector( propertyGetter ), valueObj, OBJC_ASSOCIATION_RETAIN_NONATOMIC);                       
}
</code></pre>

<p>用这个宏只需要指定相关属性的类型，getter和setter就可以快速的实现一个属性。比如在UIAlert的Category实现一个非原子retain属性userInfo，以及一个assign的类型为CGRect的customArea属性：</p>

<p>UIAlertView+Ex.h</p>

<pre><code>@interface UIAlertView (Ex)
@property(nonatomic, retain) id userInfo;
@property(nonatomic) CGRect customArea;
@end
</code></pre>

<p>UIAlertView+Ex.m</p>

<pre><code>@implementation UIAlertView (Ex)
SYNTHESIZE_CATEGORY_OBJ_PROPERTY(userInfo, setUserInfo:)
SYNTHESIZE_CATEGORY_VALUE_PROPERTY(CGRect, customArea, setCustomArea:)
@end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C中方法签名(Method Signature)机制]]></title>
    <link href="http://blog.xcodev.com/blog/2013/05/30/method-signature-in-objc/"/>
    <updated>2013-05-30T15:23:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2013/05/30/method-signature-in-objc</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>在ObjC语言中，我们会自定义各种各样的类，在类定义中，我们又会定义各种方法，当方法达到一定的数量，有时会不可避免的出现一些同名的方法。而同名的方法有时会导致运行时出现很奇怪的问题。比如传递参数不一致时，出现运行时错误。这些都和ObjC中的方法签名（Method Signature）相关。</p>

<!--more-->


<h2>什么是方法签名</h2>

<p>方法签名是ObjC中对一个方法的参数类型和返回值类型的一条记录。每个方法都对应一个方法签名。</p>

<h2>一些基本概念</h2>

<p>有几个名词在深入理解方法签名机制之前必须区分清楚：
部分可参考我之前的一篇博文：
<a href="/blog/2012/03/22/difference-between-message-and-method/">Objective-C中消息（Message）和方法（Method）的区别</a></p>

<h3>消息</h3>

<p>消息由消息的名字和参数组成，可以有返回值，用于发送给某个对象。大部分我们写的代码都是向一个对象发送消息。比如：</p>

<pre><code>[receiver message];
</code></pre>

<h3>方法</h3>

<p>方法对应一段可执行代码，是implementation的一部分。当我们向某个对象发送消息时，系统会分析我们所发送的消息，动态地调用响应的方法。对应ObjC中的IMP类型。</p>

<h3>Selector</h3>

<p>ObjC中有个SEL类型，这个类型就是Selector的类型。我们可以用@selector操作符来获取一个Selector。Selector可理解为方法的名字，但这并不包含参数和返回值，仅仅是名字。你还需注意，Selector不和任何类关联，你不能说某个Selector属于一个类，它仅仅是名字。</p>

<h2>NSMethodSignature类</h2>

<p>ObjC中有一个NSMethodSignature类，这个类很好的帮助我们来分析一下ObjC中的方法签名机制，这个类中定义了以下几个方法</p>

<pre><code>- (NSUInteger)numberOfArguments;//参数的数量
- (const char *)getArgumentTypeAtIndex:(NSUInteger)idx;//第idx个参数的类型
- (const char *)methodReturnType;//返回值类型
- (NSUInteger)methodReturnLength;//返回值长度，单位字节
</code></pre>

<p>从这些定义中我们可以看出，方法签名中会包含方法的参数个数，每个参数的类型，返回值类型，以及返回值占用的空间大小。
NSObject基类中提供了获取这个对象的方法</p>

<pre><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
</code></pre>

<p>所以，只要知道一个对象，和一个SEL（selector），那么就可以动态的获取这个方法签名了。</p>

<h2>参数类型签名不同导致的一个奇怪现象</h2>

<p>下面先举个例子，来看看参数类型签名不同导致的一个奇怪现象。
首先我们定义两个类，两个类是继承关系，但定义了同名的方法，但方法的参数类型不同。（所以它们的方法签名是不同的。）</p>

<pre><code>//基类
@interface ParamBase : NSObject
- (void)doSomeThing:(int)i;
@end

@implementation ParamBase
- (void)doSomeThing:(int)i{
    NSLog(@"Base doSomeThing called with int: %d",i);
}
@end

//子类
@interface ParamSub : ParamBase
- (void)doSomeThing:(double)d;
@end

@implementation ParamSub
- (void)doSomeThing:(double)d{
    NSLog(@"Sub doSomeThing called with double: %f",d);
}
@end
</code></pre>

<p>然后，我们创建个子类对象，然后分别在不同情况下执行doSomeThing，我们都传递相同的参数。</p>

<pre><code>ParamBase *a = [ParamSub new];
[a doSomeThing:1.0];
[(ParamSub*)a doSomeThing:1.0];
</code></pre>

<p>然后运行，你会得到如下结果。</p>

<pre><code>2013-05-30 14:25:03.242 MethodSignTest[2144:c07] Sub doSomeThing called with double: 0.000000
2013-05-30 14:25:03.244 MethodSignTest[2144:c07] Sub doSomeThing called with double: 1.000000
</code></pre>

<p>向一个对象发送了相同的消息，并且参数相同，为什么两次得到的结果不同。明明发送了1，为什么确变成0了。这其实是方法签名在编译阶段时捣鬼。当编译第二行代码时，编译器发现ParamBase对象的doSomeThing方法签名中的第一个参数是int类型，虽然代码了写的是1.0，但编译后就转换整数1了。运行时在子类的doSomeThing把整数1强制以double类型打印出来就是0了。而第3行代码就没有问题。应为编译器已经知道a已强制为ParamSub类型，而ParamSub对象doSomeThing方法签名中的第一个参数是double类型，而不是int类型，所以就没问题了。</p>

<h2>在ARC（自动引用计数机制）下返回值类型签名不同导致Crash</h2>

<p>我们再定义两个类，两个类还是继承关系，定义了同名的方法，但方法的返回值类型不同。（所以它们的方法签名也是不同的。）</p>

<pre><code>//基类
@interface ReturnBase : NSObject
- (id)getSomeThing;
@end

@implementation ReturnBase
- (id)getSomeThing{
    NSLog(@"Return Base called");
    return [NSArray new];
}
@end

//子类
@interface ReturnSub : ReturnBase
- (void)getSomeThing;
@end

@implementation ReturnSub
- (void)getSomeThing{
    NSLog(@"nothing");
}
@end
</code></pre>

<p>然后我们执行下面这段代码：</p>

<pre><code>ReturnBase *b = [ReturnSub new];
[(ReturnSub*)b getSomeThing];
[b getSomeThing];
</code></pre>

<p>结果程序在第3行Crash了，Crash类型一般是内存访问（BAD ACCESS）错误。第2行和第3行在ObjC动态绑定的机制下完全是相同的代码啊，为什么第2行没Crash，到第3行就Crash了呢？这是由于ARC和方法签名机制共同作用的结果，ARC下系统会对消息的返回值自动做一些retain或release等操作，而b在运行时ReturnSub类型，getSomeThing是不返回任何对象的。第二行时编译器知道b是ReturnSub类型，所以不会处理返回值了，而在第3行时，编译器认为b是ReturnBase类型，而根据ReturnBase类的方法getSomeThing的签名，是有返回值的，所以第3行编译后会自动对getSomeThing的返回值加一些retain/release等操作，而运行时却是没有返回值的（void类型），那么返回值就是不确定的，对这个不确定的值进行retain/release操作，一般就会导致内存访问（BAD ACCESS）错误。
也许你会想，我如果把b设为id类型，会怎样。</p>

<pre><code>id b = [ReturnSub new];
[(ReturnSub*)b getSomeThing];
[b getSomeThing];
</code></pre>

<p>结果是编译不通过，名字为getSomeThing的方法的签名不一致，编译器就不知道有没有返回值了。</p>

<h2>结论</h2>

<p>方法签名在编译时对方法的参数进行一定的转换。
ARC下会根据方法签名中的返回值进行retain/release等操作
最好不要写方法名字相同，当方法签名不同的方法，以免出现怪异现象。
有时我们改变了一个基类的参数类型或返回值类型，不要忘记了在子类中进行相应的修改。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决Xcode中Code sense无效问题]]></title>
    <link href="http://blog.xcodev.com/blog/2012/04/18/xcode-codesense-no-effect/"/>
    <updated>2012-04-18T00:45:00+08:00</updated>
    <id>http://blog.xcodev.com/blog/2012/04/18/xcode-codesense-no-effect</id>
    <content type="html"><![CDATA[<p>Code sense是Xcode中一项重要功能，它给代码加入高亮色彩，方便我们进行辨识，同时在写代码时自动提示出相关备选项，极大地提高我们的开发效率。</p>

<p>当我们写代码时，Xcode的Code sense会经常失效，严重影响开发。下面这几个步骤可以很轻松的解决这个问题。</p>

<p>首先关闭工程，点击Xcode的菜单“Window”－“Organizer”，在“Organizer”窗口中选择“Projects”标签。在左侧列表中选择你的工程或Workspace，在右侧的Derived Data行中，点击此行右边“Delete…”按钮，弹出提示时选择“Delete”。</p>

<p><img src="/images/post/code-sense-step-one.png" alt="image" /></p>

<p>经过这一步，一般再打开你的工程或Workspace，Code sense就有效了。如果仍然无效请继续以下步骤。</p>

<p>关闭Xcode，然后找到工程的目录，再工程文件上点击右键选择“显示包内容”。</p>

<p><img src="/images/post/code-sense-step-two.png" alt="image" /></p>

<p>只留下“project.pbxproj”文件，其他全部删除。</p>

<p><img src="/images/post/code-sense-step-three.png" alt="image" /></p>
]]></content>
  </entry>
  
</feed>
